## URL (URI) Parsing

```c
#define FIO_URL
#include "fio-stl.h"
```

URIs (Universal Resource Identifier), commonly referred to as URL (Uniform Resource Locator), are a common way to describe network and file addresses.

A common use case for URIs is within the command line interface (CLI), allowing a client to point at a resource that may be local (i.e., `file:///users/etc/my.conf`) or remote (i.e. `http://example.com/conf`).

By defining `FIO_URL` (or `FIO_URI`), the following types and functions will be defined.

**Note**: the parser is non-destructive, with zero-copy and zero-allocation. All returned strings are pointers into the original URL string and are **not NUL terminated**.

### Types

#### `fio_url_s`

```c
/** the result returned by `fio_url_parse` */
typedef struct {
  fio_buf_info_s scheme;
  fio_buf_info_s user;
  fio_buf_info_s password;
  fio_buf_info_s host;
  fio_buf_info_s port;
  fio_buf_info_s path;
  fio_buf_info_s query;
  fio_buf_info_s target;
} fio_url_s;
```

The `fio_url_s` contains information about a URL (or, URI).

When the information is returned from `fio_url_parse`, the strings in the `fio_url_s` (i.e., `url.scheme.buf`) are **not NUL terminated**, since the parser is non-destructive, with zero-copy and zero-allocation.

**Members:**
- `scheme` - The URL scheme (e.g., `http`, `https`, `file`)
- `user` - The username, if provided
- `password` - The password, if provided
- `host` - The host name or IP address
- `port` - The port number as a string
- `path` - The path component
- `query` - The query string (without the leading `?`)
- `target` - The fragment/target (without the leading `#`)

**Note**: empty components will have both `.buf` set to `NULL` and `.len` set to `0`.

#### `fio_url_tls_info_s`

```c
/* Return type for `fio_url_is_tls` */
typedef struct {
  fio_buf_info_s key;   /* path or env variable name for the private key */
  fio_buf_info_s cert;  /* path or env variable name for the certificate */
  fio_buf_info_s pass;  /* password for decrypting key data */
  bool tls;             /* true if TLS is requested according to the URL */
} fio_url_tls_info_s;
```

Contains TLS-related information extracted from a URL.

**Members:**
- `key` - Path or environment variable name for the private key file
- `cert` - Path or environment variable name for the public certificate file
- `pass` - Password for decrypting key/cert data
- `tls` - `true` if TLS is requested by the URL (either implicitly via scheme or explicitly via query parameters)

#### `fio_url_query_each_s`

```c
/** The type used by the `FIO_URL_QUERY_EACH` iterator macro. */
typedef struct {
  fio_buf_info_s name;
  fio_buf_info_s value;
  fio_buf_info_s private___;
} fio_url_query_each_s;
```

Iterator state type used by the `FIO_URL_QUERY_EACH` macro.

**Members:**
- `name` - The current query parameter name
- `value` - The current query parameter value
- `private___` - Internal state (do not access directly)

### API Functions

#### `fio_url_parse`

```c
fio_url_s fio_url_parse(const char *url, size_t len);
```

Parses the URI returning its components and their lengths (no decoding performed, **doesn't accept decoded URIs**).

The returned strings are **not NUL terminated**, they are merely locations within the original (unmodified) string.

This function attempts to accept many different formats, including any of the following:

* `/complete_path?query#target`

  i.e.: `/index.html?page=1#list`

* `host:port/complete_path?query#target`

  i.e.:
  - `example.com`
  - `example.com:8080`
  - `example.com/index.html`
  - `example.com:8080/index.html`
  - `example.com:8080/index.html?key=val#target`

* `user:password@host:port/path?query#target`

  i.e.: `user:1234@example.com:8080/index.html`

* `username[:password]@host[:port][...]`

  i.e.: `john:1234@example.com`

* `schema://user:password@host:port/path?query#target`

  i.e.: `http://example.com/index.html?page=1#list`

* `file://some/path`

  i.e.: `file://./relative/path` or `file:///absolute/path`

Invalid formats might produce unexpected results. No error testing performed.

**Note**: the `file`, `unix` and `priv` schemas are special in the sense that they produce no `host` (only `path`) and are parsed as if they contain file path information.

#### `fio_url_is_tls`

```c
fio_url_tls_info_s fio_url_is_tls(fio_url_s u);
```

Returns TLS data associated with the URL.

This function supports **implicit TLS** by scheme data for the following possible values:

- `wss`   - Secure WebSockets
- `sses`  - Secure SSE (Server Sent Events)
- `ssse`  - Secure SSE (alternative spelling)
- `https` - Secure HTTP
- `tcps`  - Secure TCP/IP
- `stcp`  - Secure TCP/IP (alternative spelling)
- `tls`   - Secure TCP/IP
- `ssl`   - Secure TCP/IP
- `udps`  - Secure UDP
- `sudp`  - Secure UDP (alternative spelling)

i.e.:

- `tls://example.com/`
- `tcps://example.com/`
- `udps://example.com/`
- `wss://example.com/`
- `https://example.com/`
- `sses://example.com/`

This function also supports **explicit TLS** by query data for the following possible key-pair values:

- `tls`                   - self-signed TLS (unless key / cert are provided)
- `tls=true`              - self-signed TLS (unless key / cert are provided)
- `tls=<file>`            - key and certificate files (same path / prefix, one ends with "key.pem" the other with "cert.pem")
- `key=<file/env_data>`   - path or env variable name for the private key
- `cert=<file/env_data>`  - path or env variable name for the public certificate
- `pass=<password>`       - password for decrypting key data

i.e.:

- `tcp://example.com/?tls` (anonymous TLS)
- `udp://example.com/?tls=true` (anonymous TLS)
- `https://example.com/?tls=key_cert_folder_or_prefix&pass=key_password`
- `https://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`
- `wss://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`
- `tcp://example.com/?key=key_file_or_env_var&cert=cert_file_or_env_var&pass=key_password`

### Macros

#### `FIO_URL_QUERY_EACH`

```c
/** Iterates through each of the query elements. */
#define FIO_URL_QUERY_EACH(query_buf, i)                                       \
  for (fio_url_query_each_s i = fio_url_query_each_next(                       \
           (fio_url_query_each_s){.private___ = (query_buf)});                 \
       i.name.buf;                                                             \
       i = fio_url_query_each_next(i))
```

Iterates through each of the query elements in a URL query string.

The macro accepts a `fio_buf_info_s` argument (`query_buf`) and iterates over each `name` and `value` pair in the query buffer.

Example:

```c
fio_url_s url = fio_url_parse(my_url, strlen(my_url));
FIO_URL_QUERY_EACH(url.query, param) {
  printf("  %.*s = %.*s\n",
         (int)param.name.len, param.name.buf,
         (int)param.value.len, param.value.buf);
}
```

**Note**: both `i.name` and `i.value` may be empty strings, with a valid `.buf` but with `.len` set to zero.

**Note**: the iterator does not unescape URL-encoded data. Unescaping may be required before either `i.name` or `i.value` can be used.

### Helper Functions

#### `fio_url_query_each_next`

```c
fio_url_query_each_s fio_url_query_each_next(fio_url_query_each_s i);
```

A helper function for the `FIO_URL_QUERY_EACH` macro implementation.

Advances the iterator to the next query parameter. Generally not called directly; use the `FIO_URL_QUERY_EACH` macro instead.

### Example

```c
#define FIO_URL
#include "fio-stl.h"

int main(void) {
  const char *url_str = "http://user:pass@example.com:8080/path?key=value#section";
  fio_url_s url = fio_url_parse(url_str, strlen(url_str));
  
  printf("Parsed URL:\n");
  printf("  scheme:   %.*s\n", (int)url.scheme.len, url.scheme.buf);
  printf("  user:     %.*s\n", (int)url.user.len, url.user.buf);
  printf("  password: %.*s\n", (int)url.password.len, url.password.buf);
  printf("  host:     %.*s\n", (int)url.host.len, url.host.buf);
  printf("  port:     %.*s\n", (int)url.port.len, url.port.buf);
  printf("  path:     %.*s\n", (int)url.path.len, url.path.buf);
  printf("  query:    %.*s\n", (int)url.query.len, url.query.buf);
  printf("  target:   %.*s\n", (int)url.target.len, url.target.buf);
  
  /* Iterate query parameters */
  if (url.query.buf) {
    printf("Query parameters:\n");
    FIO_URL_QUERY_EACH(url.query, param) {
      printf("  %.*s = %.*s\n",
             (int)param.name.len, param.name.buf,
             (int)param.value.len, param.value.buf);
    }
  }
  
  /* Check for TLS */
  fio_url_tls_info_s tls = fio_url_is_tls(url);
  if (tls.tls) {
    printf("TLS is enabled\n");
    if (tls.key.buf)
      printf("  key:  %.*s\n", (int)tls.key.len, tls.key.buf);
    if (tls.cert.buf)
      printf("  cert: %.*s\n", (int)tls.cert.len, tls.cert.buf);
  }
  
  return 0;
}
```

-------------------------------------------------------------------------------
