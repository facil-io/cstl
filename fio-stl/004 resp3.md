## RESP3 Parser

```c
#define FIO_RESP3
#include FIO_INCLUDE_FILE
```

By defining `FIO_RESP3`, a non-allocating, streaming, callback-based RESP3 parser is made available. This module implements the full [RESP3 specification](https://github.com/redis/redis-specifications/blob/master/protocol/RESP3.md) used by Redis 6+ and other compatible servers.

The parser uses a context-stack pattern where:

- **Primitive callbacks** return the created object as `void *`
- **Container callbacks** receive parent context and return new context
- **Push callbacks** add children to containers
- The parser manages the context stack internally

RESP3 types supported:

- **Simple types**: Simple String (`+`), Simple Error (`-`), Number (`:`), Null (`_`), Double (`,`), Boolean (`#`), Big Number (`(`)
- **Blob types**: Blob String (`$`), Blob Error (`!`), Verbatim String (`=`)
- **Aggregate types**: Array (`*`), Map (`%`), Set (`~`), Push (`>`), Attribute (`|`)
- **Streaming**: Streamed strings (`$?`), streamed aggregates (`*?`, `%?`, `~?`), chunked data (`;`), end marker (`.`)

**Note**: this module depends on `FIO_ATOL` for number parsing (included automatically).

### Configuration Macros

#### `FIO_RESP3_MAX_NESTING`

```c
#define FIO_RESP3_MAX_NESTING 32
```

The maximum number of nested layers in object responses. Valid range is 2 to 32,768. Defaults to 32.

This controls the size of the parser's internal stack. Increase it if you expect deeply nested RESP3 responses, or decrease it to save memory in constrained environments.

### RESP3 Type Constants

#### `FIO_RESP3_SIMPLE_STR`

```c
#define FIO_RESP3_SIMPLE_STR '+'
```

Simple String type marker. Wire format: `+<string>\r\n`.

#### `FIO_RESP3_SIMPLE_ERR`

```c
#define FIO_RESP3_SIMPLE_ERR '-'
```

Simple Error type marker. Wire format: `-<string>\r\n`.

#### `FIO_RESP3_NUMBER`

```c
#define FIO_RESP3_NUMBER ':'
```

Number (signed 64-bit integer) type marker. Wire format: `:<number>\r\n`.

#### `FIO_RESP3_NULL`

```c
#define FIO_RESP3_NULL '_'
```

Null type marker. Wire format: `_\r\n`.

#### `FIO_RESP3_DOUBLE`

```c
#define FIO_RESP3_DOUBLE ','
```

Double (floating-point) type marker. Wire format: `,<floating-point-number>\r\n`. Supports `inf`, `-inf`, and `nan`.

#### `FIO_RESP3_BOOL`

```c
#define FIO_RESP3_BOOL '#'
```

Boolean type marker. Wire format: `#t\r\n` (true) or `#f\r\n` (false).

#### `FIO_RESP3_BIGNUM`

```c
#define FIO_RESP3_BIGNUM '('
```

Big Number type marker. Wire format: `(<big number>\r\n`. For integers that exceed signed 64-bit range.

#### `FIO_RESP3_BLOB_STR`

```c
#define FIO_RESP3_BLOB_STR '$'
```

Blob String type marker. Wire format: `$<length>\r\n<bytes>\r\n`. Binary-safe. Also used to initiate streamed strings: `$?\r\n`.

#### `FIO_RESP3_BLOB_ERR`

```c
#define FIO_RESP3_BLOB_ERR '!'
```

Blob Error type marker. Wire format: `!<length>\r\n<bytes>\r\n`. Binary-safe error with the first uppercase word as the error code.

#### `FIO_RESP3_VERBATIM`

```c
#define FIO_RESP3_VERBATIM '='
```

Verbatim String type marker. Wire format: `=<length>\r\n<type:><bytes>\r\n`. The first 4 bytes encode a 3-character format hint (e.g., `txt:` or `mkd:`) followed by the string content.

#### `FIO_RESP3_ARRAY`

```c
#define FIO_RESP3_ARRAY '*'
```

Array type marker. Wire format: `*<count>\r\n...elements...`. An ordered collection of N elements.

#### `FIO_RESP3_MAP`

```c
#define FIO_RESP3_MAP '%'
```

Map type marker. Wire format: `%<count>\r\n...key-value pairs...`. An unordered collection of key-value pairs. The count is the number of pairs (each pair is 2 elements on the wire).

#### `FIO_RESP3_SET`

```c
#define FIO_RESP3_SET '~'
```

Set type marker. Wire format: `~<count>\r\n...elements...`. An unordered collection of unique elements.

#### `FIO_RESP3_PUSH`

```c
#define FIO_RESP3_PUSH '>'
```

Push type marker. Wire format: `><count>\r\n...elements...`. Out-of-band data (e.g., Pub/Sub messages). The first element is typically a string identifying the push type.

#### `FIO_RESP3_ATTR`

```c
#define FIO_RESP3_ATTR '|'
```

Attribute type marker. Wire format: `|<count>\r\n...key-value pairs...`. Auxiliary metadata that augments the following reply. Attributes are not part of the reply value itself.

#### `FIO_RESP3_STREAM_CHUNK`

```c
#define FIO_RESP3_STREAM_CHUNK ';'
```

Streamed string chunk marker. Wire format: `;<length>\r\n<bytes>\r\n`. Used within streamed strings (`$?\r\n`). A chunk with length 0 (`;0\r\n`) signals the end of the streamed string.

#### `FIO_RESP3_STREAM_END`

```c
#define FIO_RESP3_STREAM_END '.'
```

Streamed aggregate end marker. Wire format: `.\r\n`. Terminates streamed aggregate types (`*?`, `%?`, `~?`) and can also terminate streamed strings.

### RESP3 Types

#### `fio_resp3_frame_s`

```c
typedef struct {
  void *ctx;            /* Context for this container */
  void *key;            /* For maps: the pending key waiting for its value */
  int64_t remaining;    /* Expected remaining elements */
  uint8_t type;         /* Type of this frame (FIO_RESP3_ARRAY, etc.) */
  uint8_t streaming;    /* Is this a streaming type? */
  uint8_t expecting_value; /* For maps: expecting key (0) or value (1)? */
  uint8_t set_as_map;   /* Set treated as map (duplicates values as key+value) */
} fio_resp3_frame_s;
```

Parser frame for tracking nested structures. Each frame represents one level of nesting in the RESP3 response.

**Members:**
- `ctx` - context pointer for this container (returned by `on_array`, `on_map`, etc.)
- `key` - for map/attribute types, holds the pending key until its value arrives
- `remaining` - number of remaining elements expected in this container (-1 for streaming)
- `type` - the RESP3 type constant for this frame (e.g., `FIO_RESP3_ARRAY`)
- `streaming` - non-zero if this is a streaming (unbounded) container
- `expecting_value` - for maps: 0 when expecting a key, 1 when expecting a value
- `set_as_map` - non-zero when a RESP3 Set is being handled as a Map (when set callbacks are missing but map callbacks are provided)

**Note**: this type is part of the parser's internal state. It should not be manipulated directly.

#### `fio_resp3_parser_s`

```c
typedef struct {
  void *udata;                          /* User data passed to all callbacks */
  uint32_t depth;                       /* Current nesting depth */
  uint8_t error;                        /* Protocol error flag */
  uint8_t streaming_string;             /* Streaming string in progress flag */
  uint8_t streaming_string_type;        /* Streaming string type */
  uint8_t reserved[1];                  /* Reserved */
  void *streaming_string_ctx;           /* Context for streaming string */
  fio_resp3_frame_s stack[FIO_RESP3_MAX_NESTING]; /* Stack for nested structures */
} fio_resp3_parser_s;
```

RESP3 parser state. Maintains all state needed for incremental (streaming) parsing of RESP3 data.

**Members:**
- `udata` - user-defined data pointer passed as the first argument to all callbacks
- `depth` - current nesting depth (0 = top level)
- `error` - non-zero if a protocol error has occurred (parser is no longer usable)
- `streaming_string` - non-zero if a streamed string (`$?\r\n`) is currently being received
- `streaming_string_type` - the type of the streaming string in progress (`FIO_RESP3_BLOB_STR`, `FIO_RESP3_BLOB_ERR`, etc.)
- `streaming_string_ctx` - context pointer returned by `on_start_string` for the current streaming string
- `stack` - internal stack for tracking nested containers, sized by `FIO_RESP3_MAX_NESTING`

Initialize with `{.udata = my_context}` before first use. For continuation after partial parse, pass the same parser.

**Note**: once `error` is set, the parser will refuse further parsing. Create a new parser to recover.

#### `fio_resp3_callbacks_s`

```c
typedef struct {
  /* Primitive Callbacks - return the created object */
  void *(*on_null)(void *udata);
  void *(*on_bool)(void *udata, int is_true);
  void *(*on_number)(void *udata, int64_t num);
  void *(*on_double)(void *udata, double num);
  void *(*on_bignum)(void *udata, const void *data, size_t len);
  void *(*on_string)(void *udata, const void *data, size_t len, uint8_t type);
  void *(*on_error)(void *udata, const void *data, size_t len, uint8_t type);

  /* Container Callbacks - receive parent ctx, return new ctx */
  void *(*on_array)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_map)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_set)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_push)(void *udata, void *parent_ctx, int64_t len);
  void *(*on_attr)(void *udata, void *parent_ctx, int64_t len);

  /* Push Callbacks - add child to container */
  int (*array_push)(void *udata, void *ctx, void *value);
  int (*map_push)(void *udata, void *ctx, void *key, void *value);
  int (*set_push)(void *udata, void *ctx, void *value);
  int (*push_push)(void *udata, void *ctx, void *value);
  int (*attr_push)(void *udata, void *ctx, void *key, void *value);

  /* Done Callbacks (optional) - finalize container */
  void *(*array_done)(void *udata, void *ctx);
  void *(*map_done)(void *udata, void *ctx);
  void *(*set_done)(void *udata, void *ctx);
  void *(*push_done)(void *udata, void *ctx);
  void *(*attr_done)(void *udata, void *ctx);

  /* Error Handling */
  void (*free_unused)(void *udata, void *obj);
  void *(*on_error_protocol)(void *udata);

  /* Streaming String Callbacks (optional) */
  void *(*on_start_string)(void *udata, size_t len, uint8_t type);
  int (*on_string_write)(void *udata, void *ctx, const void *data, size_t len);
  void *(*on_string_done)(void *udata, void *ctx, uint8_t type);
} fio_resp3_callbacks_s;
```

The RESP3 parser callback table. Designed to be declared as `static const`. All callbacks receive the `udata` pointer from the parser state as their first argument.

Any callback left as NULL is replaced with a safe no-op default:

- Primitive no-ops return a non-NULL sentinel `(void *)(uintptr_t)1`
- Container no-ops return a non-NULL sentinel
- Push no-ops return 0 (success)
- Done no-ops return the context unchanged
- `free_unused` no-op does nothing
- `on_error_protocol` no-op returns NULL

**Primitive Callbacks** (return a new object as `void *`):

| Callback | Signature | Description |
|----------|-----------|-------------|
| `on_null` | `void *(*)(void *udata)` | Called when Null (`_`) is received |
| `on_bool` | `void *(*)(void *udata, int is_true)` | Called when Boolean (`#t` / `#f`) is received |
| `on_number` | `void *(*)(void *udata, int64_t num)` | Called when a Number (`:`) is parsed |
| `on_double` | `void *(*)(void *udata, double num)` | Called when a Double (`,`) is parsed |
| `on_bignum` | `void *(*)(void *udata, const void *data, size_t len)` | Called when a Big Number (`(`) is parsed; data is the raw decimal string |
| `on_string` | `void *(*)(void *udata, const void *data, size_t len, uint8_t type)` | Called for complete strings; `type` is `FIO_RESP3_SIMPLE_STR`, `FIO_RESP3_BLOB_STR`, or `FIO_RESP3_VERBATIM` |
| `on_error` | `void *(*)(void *udata, const void *data, size_t len, uint8_t type)` | Called for errors; `type` is `FIO_RESP3_SIMPLE_ERR` or `FIO_RESP3_BLOB_ERR` |

**Container Callbacks** (receive parent context, return new context as `void *`):

| Callback | Signature | Description |
|----------|-----------|-------------|
| `on_array` | `void *(*)(void *udata, void *parent_ctx, int64_t len)` | Array start; `len` is element count (-1 for streaming) |
| `on_map` | `void *(*)(void *udata, void *parent_ctx, int64_t len)` | Map start; `len` is pair count (-1 for streaming) |
| `on_set` | `void *(*)(void *udata, void *parent_ctx, int64_t len)` | Set start; `len` is element count (-1 for streaming) |
| `on_push` | `void *(*)(void *udata, void *parent_ctx, int64_t len)` | Push start; `len` is element count |
| `on_attr` | `void *(*)(void *udata, void *parent_ctx, int64_t len)` | Attribute start; `len` is pair count |

**Push Callbacks** (add child to container, return non-zero on error):

| Callback | Signature | Description |
|----------|-----------|-------------|
| `array_push` | `int (*)(void *udata, void *ctx, void *value)` | Add value to array |
| `map_push` | `int (*)(void *udata, void *ctx, void *key, void *value)` | Add key-value pair to map |
| `set_push` | `int (*)(void *udata, void *ctx, void *value)` | Add value to set |
| `push_push` | `int (*)(void *udata, void *ctx, void *value)` | Add value to push message |
| `attr_push` | `int (*)(void *udata, void *ctx, void *key, void *value)` | Add key-value pair to attribute |

**Done Callbacks** (optional, finalize container, return final object):

| Callback | Signature | Description |
|----------|-----------|-------------|
| `array_done` | `void *(*)(void *udata, void *ctx)` | Finalize array; return final object |
| `map_done` | `void *(*)(void *udata, void *ctx)` | Finalize map; return final object |
| `set_done` | `void *(*)(void *udata, void *ctx)` | Finalize set; return final object |
| `push_done` | `void *(*)(void *udata, void *ctx)` | Finalize push; return final object |
| `attr_done` | `void *(*)(void *udata, void *ctx)` | Finalize attribute; return final object |

**Error Handling:**

| Callback | Signature | Description |
|----------|-----------|-------------|
| `free_unused` | `void (*)(void *udata, void *obj)` | Free an orphaned object (e.g., a map key whose value failed) |
| `on_error_protocol` | `void *(*)(void *udata)` | Called on protocol error |

**Streaming String Callbacks** (all three must be provided, or none):

| Callback | Signature | Description |
|----------|-----------|-------------|
| `on_start_string` | `void *(*)(void *udata, size_t len, uint8_t type)` | Called when a blob string starts; `len` is declared length (`(size_t)-1` for streaming); return context for string builder, or NULL to fall back to `on_string` |
| `on_string_write` | `int (*)(void *udata, void *ctx, const void *data, size_t len)` | Called with partial data; return non-zero to abort |
| `on_string_done` | `void *(*)(void *udata, void *ctx, uint8_t type)` | Called when string is complete; return final string object |

**Note**: when `on_set`, `set_push`, and `set_done` are all NULL but map callbacks are provided, the parser automatically treats RESP3 Sets as Maps (each element is used as both key and value in `map_push`).

#### `fio_resp3_result_s`

```c
typedef struct {
  void *obj;       /* The parsed top-level object (or NULL on error/incomplete) */
  size_t consumed; /* Number of bytes consumed from the buffer */
  int err;         /* Non-zero if an error occurred */
} fio_resp3_result_s;
```

The RESP3 parse result type returned by `fio_resp3_parse`.

**Members:**
- `obj` - the parsed top-level object, or NULL if the data is incomplete or an error occurred
- `consumed` - number of bytes consumed from the input buffer; unconsumed bytes should be retained for the next call
- `err` - non-zero if a protocol error occurred; the parser is no longer usable after an error

### RESP3 Functions

#### `fio_resp3_parse`

```c
fio_resp3_result_s fio_resp3_parse(fio_resp3_parser_s *parser,
                                   const fio_resp3_callbacks_s *callbacks,
                                   const void *buf,
                                   size_t len);
```

Parses RESP3 data from a buffer.

Processes as much data as possible from `buf`, invoking the appropriate callbacks for each parsed element. For partial data, the parser state is preserved; call again with remaining data appended to unconsumed bytes.

**Parameters:**
- `parser` - parser state; initialize with `{.udata = my_data}` for first call, reuse for continuation
- `callbacks` - callback table (should be `static const`); NULL callbacks are replaced with safe no-ops
- `buf` - pointer to the data to parse
- `len` - length of the data in bytes

**Returns:** a `fio_resp3_result_s` containing:
- `obj` - the parsed top-level object (NULL if incomplete or error)
- `consumed` - number of bytes consumed from `buf`
- `err` - non-zero if a protocol error occurred

**Note**: after a protocol error (`err != 0`), the parser is permanently in an error state. A new parser must be created to continue parsing.

**Note**: attributes (`|`) are consumed and delivered via callbacks but do not count as reply values. After an attribute completes at the top level, the parser continues to read the actual reply.

**Note**: for streamed strings (`$?\r\n`), the streaming string callbacks (`on_start_string`, `on_string_write`, `on_string_done`) must be provided. If they are not, the parser sets an error because it cannot buffer unknown-length data.

### RESP3 Examples

#### Basic Usage

```c
#define FIO_RESP3
#include FIO_INCLUDE_FILE

/* --- Minimal callback implementations --- */

static void *my_on_null(void *udata) {
  /* Create and return your null representation */
  return my_obj_new_null();
  (void)udata;
}

static void *my_on_number(void *udata, int64_t num) {
  return my_obj_new_int(num);
  (void)udata;
}

static void *my_on_string(void *udata, const void *data,
                           size_t len, uint8_t type) {
  return my_obj_new_string(data, len);
  (void)udata; (void)type;
}

static void *my_on_array(void *udata, void *parent_ctx, int64_t len) {
  return my_obj_new_array(len);
  (void)udata; (void)parent_ctx;
}

static int my_array_push(void *udata, void *ctx, void *value) {
  my_obj_array_push(ctx, value);
  return 0;
  (void)udata;
}

static void *my_array_done(void *udata, void *ctx) {
  return ctx; /* array is already built */
  (void)udata;
}

static void my_free_unused(void *udata, void *obj) {
  my_obj_free(obj);
  (void)udata;
}

/* --- Parsing --- */

void parse_redis_response(const void *buf, size_t len) {
  static const fio_resp3_callbacks_s callbacks = {
      .on_null = my_on_null,
      .on_number = my_on_number,
      .on_string = my_on_string,
      .on_array = my_on_array,
      .array_push = my_array_push,
      .array_done = my_array_done,
      .free_unused = my_free_unused,
  };

  fio_resp3_parser_s parser = {.udata = NULL};
  fio_resp3_result_s result =
      fio_resp3_parse(&parser, &callbacks, buf, len);

  if (result.err) {
    fprintf(stderr, "RESP3 protocol error\n");
    return;
  }
  if (result.obj) {
    /* Process the parsed object */
    process_result(result.obj);
  }
  /* result.consumed bytes were consumed; retain the rest for next call */
}
```

#### Incremental (Streaming) Parsing

```c
void handle_socket_data(fio_resp3_parser_s *parser,
                        const fio_resp3_callbacks_s *cb,
                        const void *buf, size_t len) {
  fio_resp3_result_s result = fio_resp3_parse(parser, cb, buf, len);

  if (result.err) {
    /* Protocol error - close connection */
    close_connection();
    return;
  }

  if (result.obj) {
    /* Complete response received */
    dispatch_response(result.obj);
  }

  if (result.consumed < len) {
    /* Partial data remains - buffer unconsumed bytes for next read */
    buffer_remaining(
        (const char *)buf + result.consumed,
        len - result.consumed);
  }
}
```

### RESP3 Wire Format Reference

| Type | Marker | Format | Example |
|------|--------|--------|---------|
| Simple String | `+` | `+<string>\r\n` | `+OK\r\n` |
| Simple Error | `-` | `-<string>\r\n` | `-ERR unknown\r\n` |
| Number | `:` | `:<integer>\r\n` | `:42\r\n` |
| Null | `_` | `_\r\n` | `_\r\n` |
| Double | `,` | `,<double>\r\n` | `,3.14\r\n` |
| Boolean | `#` | `#t\r\n` or `#f\r\n` | `#t\r\n` |
| Big Number | `(` | `(<digits>\r\n` | `(12345678901234567890\r\n` |
| Blob String | `$` | `$<len>\r\n<bytes>\r\n` | `$5\r\nhello\r\n` |
| Blob Error | `!` | `!<len>\r\n<bytes>\r\n` | `!11\r\nERR unknown\r\n` |
| Verbatim | `=` | `=<len>\r\n<fmt:><bytes>\r\n` | `=10\r\ntxt:hello!\r\n` |
| Array | `*` | `*<count>\r\n...` | `*2\r\n:1\r\n:2\r\n` |
| Map | `%` | `%<pairs>\r\n...` | `%1\r\n+a\r\n:1\r\n` |
| Set | `~` | `~<count>\r\n...` | `~2\r\n:1\r\n:2\r\n` |
| Push | `>` | `><count>\r\n...` | `>2\r\n+msg\r\n+hi\r\n` |
| Attribute | `\|` | `\|<pairs>\r\n...` | `\|1\r\n+ttl\r\n:3600\r\n` |
| Stream Chunk | `;` | `;<len>\r\n<bytes>\r\n` | `;5\r\nhello\r\n` |
| Stream End | `.` | `.\r\n` | `.\r\n` |

------------------------------------------------------------
