## IPC - Inter-Process Communication

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE
```

The IPC module provides secure, high-performance inter-process communication between master and worker processes in the facil.io framework. It enables workers to call functions on the master process, receive streaming replies, and broadcast messages to all workers.

Key features:

- **Worker-to-Master Calls**: Workers can invoke arbitrary code on the master process with reply callbacks
- **Streaming Replies**: Master can send multiple replies before signaling completion
- **Local Broadcasting**: Broadcast messages to all processes on the local machine
- **Cluster Communication**: Send messages to remote machines in a cluster
- **Global Broadcasting**: Execute code on ALL processes on ALL machines
- **Encrypted Transport**: All IPC messages are encrypted with ChaCha20-Poly1305 AEAD
- **Reference Counting**: Messages use reference counting for safe memory management
- **Zero-Copy Buffer Concatenation**: Multiple buffers can be combined without intermediate allocation

### Execution Scope Overview

The IPC module provides functions with different execution scopes:

| Function | Flags Set | Execution Scope |
|----------|-----------|-----------------|
| `fio_ipc_call` | (none) | Master only |
| `fio_ipc_local` | `.workers = 1` | Master + all workers (local machine) |
| `fio_ipc_cluster` | `.cluster = 1` | Master on each remote machine only |
| `fio_ipc_broadcast` | `.workers = 1, .cluster = 1` | ALL processes on ALL machines |
| `fio_ipc_reply` | N/A | Caller only (reply to request) |

**Note**: Use `.others = true` to exclude the calling process from execution.

### IPC Message Types

#### `fio_ipc_s`

```c
typedef struct fio_ipc_s {
  fio_io_s *from; /* IO to caller - set by receiver (not transmitted) */
  /* ----- wire format starts here ----- */
  uint32_t len;   /* Length of data[] (AAD - authenticated, unencrypted) */
  uint16_t flags; /* User settable flags (AAD - authenticated, unencrypted) */
  uint16_t private_flags; /* Internal (AAD - authenticated, unencrypted) */
  uint64_t timestamp;     /* timestamp (unencrypted, used for nonce) */
  uint64_t id;            /* 8 random bytes (unencrypted, used for nonce) */
  union {
    void (*call)(struct fio_ipc_s *); /* function pointer (local IPC) */
    uint32_t opcode;                  /* op-code (cluster RPC) */
  };
  void (*on_reply)(struct fio_ipc_s *); /* run on caller (encrypted) */
  void (*on_done)(struct fio_ipc_s *);  /* run on caller (encrypted) */
  void *udata; /* opaque, valid only in caller (encrypted) */
  char data[]; /* Variable-length data + 16-byte MAC at end (encrypted) */
} fio_ipc_s;
```

The IPC message structure contains all information needed for a request/response cycle. Messages are reference-counted and encrypted before transmission.

**Members:**

- `from` - Pointer to the caller's IO connection (set by receiver, used for replies; not transmitted)
- `len` - Length of the `data[]` payload in bytes (part of authenticated additional data)
- `flags` - User-settable flags, preserved through the call/reply cycle (part of AAD)
- `private_flags` - Internal flags used by the IPC system (do not modify)
- `timestamp` - Millisecond timestamp, used as part of the encryption nonce
- `id` - Random 64-bit identifier, used as part of the encryption nonce
- `call` / `opcode` - Union: function pointer for local IPC, or op-code for cluster RPC
- `on_reply` - Function pointer executed on the caller when a reply is received
- `on_done` - Function pointer executed on the caller when all replies are complete
- `udata` - Opaque user data pointer, valid only in the calling process
- `data` - Flexible array member containing the message payload

**Note**: The `from` field is NOT part of the wire format. The wire format starts at `len`. The `call`/`opcode`, `on_reply`, `on_done`, `udata`, and `data` fields are encrypted during transmission.

#### `fio_ipc_args_s`

```c
typedef struct {
  void (*call)(fio_ipc_s *);     /** Function to execute on target process */
  void (*on_reply)(fio_ipc_s *); /** Callback when reply received */
  void (*on_done)(fio_ipc_s *);  /** Callback when all replies done */
  uint64_t timestamp;            /** Optional: force timestamp (0 = current time) */
  uint64_t id;                   /** Optional: force ID (0 = random) */
  uint32_t opcode;               /** Replaces `call` with op-code if non-zero */
  uint16_t flags;                /** User-settable flags */
  bool cluster;                  /** If set, intended for all machines in cluster */
  bool workers;                  /** If set, intended for master + workers */
  bool others;                   /** If set, will not run on calling process */
  void *udata;                   /** Opaque user data (caller-side only) */
  fio_buf_info_s *data;          /** Array of buffers for message payload */
} fio_ipc_args_s;
```

Arguments structure for creating IPC messages. Used by `fio_ipc_new` and the main API macros.

**Key Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `call` | `void (*)(fio_ipc_s *)` | Function executed on target. Required for local IPC. |
| `on_reply` | `void (*)(fio_ipc_s *)` | Called when reply received. Optional. |
| `on_done` | `void (*)(fio_ipc_s *)` | Called when all replies done. Optional. |
| `opcode` | `uint32_t` | Op-code for cluster RPC. Replaces `call` if non-zero. |
| `cluster` | `bool` | Send to remote machines in cluster. |
| `workers` | `bool` | Send to master + all workers on local machine. |
| `others` | `bool` | Exclude calling process from execution. |
| `udata` | `void *` | Opaque user data (not transmitted). |
| `data` | `fio_buf_info_s *` | Message payload. Use `FIO_IPC_DATA()` macro. |

#### `fio_ipc_opcode_s`

```c
typedef struct fio_ipc_opcode_s {
  uint32_t opcode;                      /** Unique op-code value */
  void (*call)(struct fio_ipc_s *);     /** Function to call */
  void (*on_reply)(struct fio_ipc_s *); /** Reply callback */
  void (*on_done)(struct fio_ipc_s *);  /** Reply finished callback */
  void *udata;                          /** Opaque user data */
} fio_ipc_opcode_s;
```

Structure for registering op-code handlers for cluster RPC communication.

**Members:**

- `opcode` - Unique non-zero op-code value (values >= `0xFF000000` are reserved)
- `call` - Function executed when message with this op-code is received
- `on_reply` - Function executed when a reply is received
- `on_done` - Function executed when all replies are complete
- `udata` - User data passed to handlers via `ipc->udata`

#### `fio_ipc_reply_args_s`

```c
typedef struct {
  fio_ipc_s *ipc;       /** The IPC message being replied to. Required. */
  fio_buf_info_s *data; /** Array of buffers for reply payload */
  uint64_t timestamp;   /** Optional: override timestamp (0 = current time) */
  uint64_t id;          /** Optional: override ID (0 = original request ID) */
  uint16_t flags;       /** Optional: override flags (0 = original flags) */
  uint8_t done;         /** Set to 1 on final reply to trigger on_done */
  uint8_t flags_set;    /** Set to 1 to use flags value (allows flags=0) */
} fio_ipc_reply_args_s;
```

Arguments structure for sending replies.

### Configuration Macros

#### `FIO_IPC_URL_MAX_LENGTH`

```c
#ifndef FIO_IPC_URL_MAX_LENGTH
#define FIO_IPC_URL_MAX_LENGTH 1024
#endif
```

Maximum length for the IPC socket URL. Default is 1024 characters.

#### `FIO_IPC_MAX_LENGTH`

```c
#ifndef FIO_IPC_MAX_LENGTH
#define FIO_IPC_MAX_LENGTH (128ULL * 1024U * 1024U)
#endif
```

Maximum length for IPC message payloads. Default is 128 MB. Messages exceeding this limit will fail to be created.

### Utility Macros

#### `FIO_IPC_DATA`

```c
#define FIO_IPC_DATA(...)                                                      \
  (fio_buf_info_s[]) {                                                         \
    __VA_ARGS__, { 0 }                                                         \
  }
```

A helper macro for composing multiple buffers into a single IPC message. The macro creates a `fio_buf_info_s` array terminated by a zero-length entry.

This enables zero-copy buffer concatenation - multiple buffers are combined into the IPC message without requiring an intermediate allocation.

Example usage:

```c
/* Combine a string header with binary data */
const char *header = "MSG:";
uint64_t value = 0xDEADBEEF;

fio_ipc_call(.call = my_handler,
             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)header),
                                  FIO_BUF_INFO2(&value, sizeof(value))));
```

**Note**: Data is copied synchronously when the IPC function is called, before the operation is deferred. Source buffers can be stack-allocated or freed immediately after the call.

**Note**: When sending a struct with a flexible array member, use `offsetof(struct_type, flex_member)` instead of `sizeof(struct_type)` to get the correct size without padding.

#### `FIO_IPC_EXCLUDE_SELF`

```c
#define FIO_IPC_EXCLUDE_SELF ((fio_io_s *)((char *)-1LL))
```

Special value that can be set in `ipc->from` before calling `fio_ipc_send` to exclude the current process from receiving the message. Alternatively, use `.others = true` in `fio_ipc_args_s`.

### Main API

The main API consists of four macros that create and send IPC messages with different execution scopes. All macros use named arguments via `fio_ipc_args_s`.

#### `fio_ipc_call`

```c
#define fio_ipc_call(...) fio_ipc_send(fio_ipc_new(__VA_ARGS__))
```

Call arbitrary code on the **master process only** (worker -> master or master -> master).

The `call` function pointer is executed on the master process. When called from a worker, the message is sent over the IPC socket. When called from the master, execution is deferred via `fio_io_defer`.

Replies are sent back to the caller via the `on_reply` callback. When all replies are complete (signaled by `done = 1` in `fio_ipc_reply`), the `on_done` callback is invoked.

```c
/* Worker calls master to process data */
fio_ipc_call(.call = process_on_master,
             .on_reply = handle_reply,
             .on_done = cleanup,
             .udata = my_context,
             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"request_data")));
```

#### `fio_ipc_local`

```c
#define fio_ipc_local(...) fio_ipc_send(fio_ipc_new(.workers = 1, __VA_ARGS__))
```

Execute a callback on **all processes on the local machine** (master + all workers).

The `call` function pointer is executed on the master and all worker processes.

```c
/* Broadcast to all local processes */
fio_ipc_local(.call = handle_local_broadcast,
              .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"local_data")));

/* Broadcast to all local processes EXCEPT self */
fio_ipc_local(.others = true,
              .call = handle_local_broadcast,
              .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"to_others")));
```

**Note**: When called from a worker, the message is sent to the master, which then re-broadcasts to all workers.

#### `fio_ipc_cluster`

```c
#define fio_ipc_cluster(...) fio_ipc_send(fio_ipc_new(.cluster = 1, __VA_ARGS__))
```

Send a message to the **master process on each connected remote machine**. Does **NOT** execute locally.

Requires an op-code (not a function pointer) since function pointers cannot be transmitted across machines.

```c
/* Send to remote machines only (no local execution) */
fio_ipc_cluster(.opcode = OP_SYNC_DATA,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"sync_payload")));
```

**Note**: Use `fio_ipc_broadcast` if you need execution on all machines including local.

#### `fio_ipc_broadcast`

```c
#define fio_ipc_broadcast(...) fio_ipc_send(fio_ipc_new(.workers = 1, .cluster = 1, __VA_ARGS__))
```

Execute an op-code callback on **ALL processes on ALL machines** (local + remote).

The op-code handler executes on:
- All local processes (master + workers) on this machine
- All processes (master + workers) on all connected remote machines

```c
/* Broadcast to ALL processes on ALL machines */
fio_ipc_broadcast(.opcode = OP_CACHE_INVALIDATE,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"cache_key")));

/* Broadcast to all except current process */
fio_ipc_broadcast(.opcode = OP_CONFIG_UPDATE,
                  .others = true,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"config_data")));
```

**Note**: Requires a registered op-code handler via `fio_ipc_opcode_register()`.

### Reply Function

#### `fio_ipc_reply`

```c
SFUNC void fio_ipc_reply(fio_ipc_reply_args_s args);
/* Named arguments using macro. */
#define fio_ipc_reply(r, ...)                                                  \
  fio_ipc_reply((fio_ipc_reply_args_s){.ipc = (r), __VA_ARGS__})
```

Send a response to the caller process (master -> caller).

Can be called multiple times for streaming responses. Set `done = 1` on the last reply to signal completion and trigger the caller's `on_done` callback.

The function is shadowed by a macro. The first argument is the IPC message being replied to:

```c
/* Master handler sends streaming replies */
void my_handler(fio_ipc_s *msg) {
  /* Send intermediate reply */
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"chunk1")),
                .done = 0);
  
  /* Send final reply */
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"final")),
                .done = 1);
}
```

**Note**: The reply inherits `call`, `on_reply`, `on_done`, and `udata` from the original request.

### Op-Code Registration

Op-codes enable cluster-wide RPC by mapping integer codes to handler functions. Since function pointers cannot be transmitted across machines, op-codes provide a portable way to invoke remote handlers.

#### `fio_ipc_opcode_register`

```c
SFUNC int fio_ipc_opcode_register(fio_ipc_opcode_s opcode);
/* Named arguments using macro. */
#define fio_ipc_opcode_register(...)                                           \
  fio_ipc_opcode_register((fio_ipc_opcode_s){__VA_ARGS__})
```

Registers an op-code handler for message routing.

There are two types of messages:
1. **Fast Path** - Function pointers in the message payload (local IPC only)
2. **Safe Path** - Op-code in the `call` payload (multi-machine RPC)

```c
/* Define op-codes */
#define OP_SYNC_DATA    1
#define OP_INVALIDATE   2

/* Handler for sync data messages */
void on_sync_data(fio_ipc_s *msg) {
  printf("Received sync data: %.*s\n", (int)msg->len, msg->data);
}

/* Register before starting reactor */
fio_ipc_opcode_register(.opcode = OP_SYNC_DATA,
                        .call = on_sync_data,
                        .udata = NULL);

/* To unregister, set call to NULL */
fio_ipc_opcode_register(.opcode = OP_SYNC_DATA, .call = NULL);
```

**Returns:** 0 on success, -1 on failure.

**Note**: Op-codes MUST be non-zero `uint32_t` values. Values >= `0xFF000000` are reserved for internal use.

**Note**: Thread safety requires this be called **before** `fio_io_start()`.

#### `fio_ipc_opcode`

```c
SFUNC const fio_ipc_opcode_s *fio_ipc_opcode(uint32_t opcode);
```

Returns a pointer to a registered op-code structure, or NULL if not found.

**Parameters:**

- `opcode` - The op-code to look up

**Returns:** Pointer to the registered `fio_ipc_opcode_s`, or NULL if not registered.

```c
const fio_ipc_opcode_s *op = fio_ipc_opcode(OP_SYNC_DATA);
if (op) {
  printf("Op-code %u is registered\n", op->opcode);
}
```

### Core Functions

These functions provide low-level control over IPC message creation and sending.

#### `fio_ipc_new`

```c
SFUNC fio_ipc_s *fio_ipc_new(fio_ipc_args_s args);
/* Named arguments using macro. */
#define fio_ipc_new(...) fio_ipc_new((fio_ipc_args_s){__VA_ARGS__})
```

Authors a message without sending it.

Used internally by the main API macros. Also available for "faking" IPC or when composing a unified code path for local execution.

```c
/* Create a message for manual handling */
fio_ipc_s *msg = fio_ipc_new(.call = my_handler,
                             .on_reply = my_reply_handler,
                             .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"data")));
/* ... use message ... */
fio_ipc_free(msg);
```

**Returns:** A new IPC message, or NULL on allocation failure.

#### `fio_ipc_send`

```c
SFUNC void fio_ipc_send(fio_ipc_s *ipc);
```

Encrypts the IPC message, sends it for execution based on flags, and frees it.

Message routing is determined by the flags set during creation:
- No flags: Send to master only (`fio_ipc_call`)
- `.workers = 1`: Send to master + workers (`fio_ipc_local`)
- `.cluster = 1`: Send to remote masters (`fio_ipc_cluster`)
- `.workers = 1, .cluster = 1`: Send to all (`fio_ipc_broadcast`)

**Parameters:**

- `ipc` - The IPC message to send (ownership transferred)

**Note**: Takes ownership of the message's memory. The message is encrypted and unusable once the call returns.

**Note**: If `ipc->from == FIO_IPC_EXCLUDE_SELF`, the calling process is excluded from execution.

#### `fio_ipc_send_to`

```c
SFUNC void fio_ipc_send_to(fio_io_s *to, fio_ipc_s *ipc);
```

Encrypts the IPC message and sends it directly to a specific IO connection, then frees the message.

**Parameters:**

- `to` - Target IO connection to send the message to
- `ipc` - The IPC message to send (ownership transferred)

**Note**: Takes ownership of the message's memory.

**Note**: If `to` is NULL, the message is freed without sending.

#### `fio_ipc_dup`

```c
SFUNC fio_ipc_s *fio_ipc_dup(fio_ipc_s *msg);
```

Duplicate a message by incrementing its reference count.

Use when storing messages for later processing. Every `fio_ipc_dup()` must be matched with a corresponding `fio_ipc_free()`.

**Returns:** The same pointer with incremented reference count.

```c
void my_handler(fio_ipc_s *msg) {
  /* Store message for async processing */
  fio_ipc_s *stored = fio_ipc_dup(msg);
  schedule_async_work(stored);
}

void async_work_done(fio_ipc_s *msg) {
  /* Process and free */
  process_data(msg->data, msg->len);
  fio_ipc_free(msg);
}
```

#### `fio_ipc_free`

```c
SFUNC void fio_ipc_free(fio_ipc_s *msg);
```

Free a message by decrementing its reference count.

The message is destroyed when the reference count reaches zero.

**Note**: Messages passed to callbacks are automatically freed after the callback returns. Only call `fio_ipc_free` on messages you have explicitly duplicated with `fio_ipc_dup`.

#### `fio_ipc_detach`

```c
SFUNC void fio_ipc_detach(fio_ipc_s *msg);
```

Detaches the IPC message from its originating IO connection.

Call this function if storing the message or performing non-IPC actions using the IPC message. This releases the reference to the `from` IO connection, preventing potential issues if the connection closes while the message is still in use.

**Parameters:**

- `msg` - The IPC message to detach

**Note**: After calling `fio_ipc_detach`, the `msg->from` field will be NULL and replies cannot be sent using this message.

#### `fio_ipc_after_send`

```c
SFUNC void fio_ipc_after_send(fio_ipc_s *ipc,
                              void (*fn)(fio_ipc_s *, void *),
                              void *udata);
```

Set a callback to execute when the last reference is freed (e.g., sending complete).

Use this to prevent race conditions between the encrypted state required for sending and the unencrypted state used for code execution.

**Parameters:**

- `ipc` - The IPC message
- `fn` - Callback function to execute after sending completes
- `udata` - User data passed to the callback

**Note**: This is a one-shot callback.

### Encryption Functions

#### `fio_ipc_encrypt`

```c
SFUNC void fio_ipc_encrypt(fio_ipc_s *m);
```

Encrypt an IPC message before sending.

**Note**: Messages are automatically encrypted by `fio_ipc_send` and `fio_ipc_send_to`. This function is only needed for manual message handling.

**Note**: Encryption is idempotent - calling on an already-encrypted message has no effect.

#### `fio_ipc_decrypt`

```c
FIO_IFUNC int fio_ipc_decrypt(fio_ipc_s *m);
```

Decrypt an IPC message when received.

**Returns:** 0 on success, non-zero on failure (e.g., MAC verification failed).

**Note**: If decryption fails, a security log message is emitted. This may indicate message tampering or an attack.

**Note**: Decryption is idempotent - calling on an already-decrypted message returns 0 immediately.

### Cluster Functions

The cluster subsystem extends IPC to support communication between multiple server instances across machines.

#### `fio_ipc_cluster_listen`

```c
SFUNC fio_io_listener_s *fio_ipc_cluster_listen(uint16_t port);
```

Listens for cluster connections on the specified port and auto-connects to peers via UDP discovery.

All server instances get all `cluster` messages (e.g., pub/sub cluster). Uses the environment's (shared) secret for rudimentary encryption without forward secrecy.

**Parameters:**

- `port` - TCP/UDP port to listen on for cluster connections

**Returns:** A listener handle on success, or NULL on error.

**Note**: Requires a shared secret via the `SECRET` environment variable. Returns NULL if using a random secret.

**Note**: Rotate secrets when possible (requires restart). Good for trusted data centers, Kubernetes pods, etc.

```c
/* Start cluster listener on port 9000 */
fio_io_listener_s *listener = fio_ipc_cluster_listen(9000);
if (!listener) {
  fprintf(stderr, "Failed to start cluster - check SECRET env var\n");
}
```

#### `fio_ipc_cluster_connect`

```c
SFUNC void fio_ipc_cluster_connect(const char *url);
```

Manually connects to a cluster peer.

Usually unnecessary since UDP discovery handles peer connections automatically. Use this for connecting to peers on different subnets or when UDP broadcast is not available.

**Parameters:**

- `url` - URL of the remote peer (e.g., `"tcp://192.168.1.100:9000"`)

```c
/* Manually connect to a peer */
fio_ipc_cluster_connect("tcp://192.168.1.100:9000");
```

#### `fio_ipc_cluster_port`

```c
SFUNC uint16_t fio_ipc_cluster_port(void);
```

Returns the last port number passed to `fio_ipc_cluster_listen`, or zero if cluster listening has not been started.

**Returns:** The cluster port number, or 0 if not listening.

```c
uint16_t port = fio_ipc_cluster_port();
if (port) {
  printf("Cluster listening on port %u\n", (unsigned)port);
}
```

### URL Management Functions

#### `fio_ipc_url`

```c
SFUNC const char *fio_ipc_url(void);
```

Returns the IPC URL used for the listening socket.

**Returns:** The current IPC socket URL string.

```c
const char *url = fio_ipc_url();
printf("IPC socket: %s\n", url);
/* Output: IPC socket: unix://fio_tmp_XXXXXXXXXXXX.sock */
```

#### `fio_ipc_url_set`

```c
SFUNC int fio_ipc_url_set(const char *url);
```

Sets the IPC URL for the listening socket.

Can only be called on the master process and only before the IO reactor starts.

**Parameters:**

- `url` - The URL to use, or NULL to auto-generate

**Returns:** 0 on success, -1 on error.

**Note**: If `url` is NULL or too short, an auto-generated URL of the form `unix://fio_tmp_XXXXXXXXXXXX.sock` is used.

**Note**: URLs ending in `XXX` or `...` will have the suffix replaced with random characters.

```c
/* Set custom IPC socket path */
if (fio_ipc_url_set("unix:///var/run/myapp.sock") != 0) {
  fprintf(stderr, "Failed to set IPC URL\n");
}

/* Or use auto-generated URL */
fio_ipc_url_set(NULL);
```

### Examples

#### Basic Worker-to-Master Call with Reply

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Handler executed on master */
void master_handler(fio_ipc_s *msg) {
  printf("Master received: %.*s\n", (int)msg->len, msg->data);
  
  /* Send reply back to worker */
  const char *reply = "processed";
  fio_ipc_reply(msg,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)reply)),
                .done = 1);
}

/* Called on worker when reply received */
void on_reply(fio_ipc_s *msg) {
  printf("Worker received reply: %.*s\n", (int)msg->len, msg->data);
}

/* Called on worker when all replies done */
void on_done(fio_ipc_s *msg) {
  printf("Request complete\n");
  (void)msg;
}

/* Worker startup */
void worker_start(void *arg) {
  (void)arg;
  if (!fio_io_is_worker())
    return;
  
  const char *request = "hello from worker";
  fio_ipc_call(.call = master_handler,
               .on_reply = on_reply,
               .on_done = on_done,
               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)request)));
}

int main(void) {
  fio_state_callback_add(FIO_CALL_ON_START, worker_start, NULL);
  fio_io_start(2);  /* Start with 2 workers */
  return 0;
}
```

#### Local Broadcasting to All Workers

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Handler executed on each local process */
void local_handler(fio_ipc_s *msg) {
  printf("Process %d received: %.*s\n",
         fio_io_pid(), (int)msg->len, msg->data);
}

/* Timer callback to trigger local broadcast */
int trigger_local_broadcast(void *arg1, void *arg2) {
  (void)arg1; (void)arg2;
  if (!fio_io_is_master())
    return -1;
  
  const char *data = "config_update";
  fio_ipc_local(.call = local_handler,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
  return -1;  /* One-shot timer */
}

int main(void) {
  /* Trigger broadcast after 100ms (let workers connect) */
  fio_io_run_every(.fn = trigger_local_broadcast,
                   .every = 100,
                   .repetitions = 1);
  
  fio_io_start(4);  /* Start with 4 workers */
  return 0;
}
```

#### Cluster-Wide Broadcast (All Machines)

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Op-codes */
#define OP_CACHE_INVALIDATE 1
#define OP_CONFIG_UPDATE    2

/* Handler for cache invalidation - runs on ALL processes on ALL machines */
void on_cache_invalidate(fio_ipc_s *msg) {
  printf("[%d] Cache invalidate: %.*s\n",
         fio_io_pid(), (int)msg->len, msg->data);
  /* Invalidate local cache entry */
  cache_remove(msg->data, msg->len);
}

/* Handler for config updates */
void on_config_update(fio_ipc_s *msg) {
  printf("[%d] Config update received\n", fio_io_pid());
  /* Reload configuration */
  config_reload();
  (void)msg;
}

int main(void) {
  /* Register op-codes before starting */
  fio_ipc_opcode_register(.opcode = OP_CACHE_INVALIDATE,
                          .call = on_cache_invalidate);
  fio_ipc_opcode_register(.opcode = OP_CONFIG_UPDATE,
                          .call = on_config_update);
  
  /* Start cluster listener (requires SECRET env var) */
  if (!fio_ipc_cluster_listen(9000)) {
    fprintf(stderr, "Cluster disabled - set SECRET env var for multi-machine support\n");
  }
  
  /* Start IO reactor */
  fio_io_start(4);
  return 0;
}

/* Called elsewhere to broadcast cache invalidation to ALL processes */
void invalidate_cache_cluster_wide(const char *key) {
  /* This executes on ALL processes on ALL machines */
  fio_ipc_broadcast(.opcode = OP_CACHE_INVALIDATE,
                    .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)key)));
}

/* Called elsewhere to notify only remote machines */
void sync_to_remote_machines(const char *data) {
  /* This executes ONLY on remote machine masters */
  fio_ipc_cluster(.opcode = OP_CONFIG_UPDATE,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
}
```

#### Using FIO_IPC_DATA for Multi-Buffer Messages

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Message structure */
typedef struct {
  uint32_t type;
  uint32_t sequence;
} msg_header_t;

void master_handler(fio_ipc_s *msg) {
  /* Parse combined data */
  if (msg->len < sizeof(msg_header_t))
    return;
  
  msg_header_t header;
  memcpy(&header, msg->data, sizeof(header));
  
  const char *payload = msg->data + sizeof(header);
  size_t payload_len = msg->len - sizeof(header);
  
  printf("Type: %u, Seq: %u, Payload: %.*s\n",
         header.type, header.sequence,
         (int)payload_len, payload);
}

void send_message(void) {
  msg_header_t header = {.type = 1, .sequence = 42};
  const char *payload = "message payload";
  
  /* Combine header and payload without intermediate buffer */
  fio_ipc_call(.call = master_handler,
               .data = FIO_IPC_DATA(
                   FIO_BUF_INFO2(&header, sizeof(header)),
                   FIO_BUF_INFO1((char *)payload)));
}
```

#### Streaming Replies Pattern

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

/* Master handler that sends streaming replies */
void stream_handler(fio_ipc_s *msg) {
  /* Simulate processing chunks of data */
  for (int i = 0; i < 5; ++i) {
    char chunk[64];
    int len = snprintf(chunk, sizeof(chunk), "chunk_%d", i + 1);
    
    fio_ipc_reply(msg,
                  .data = FIO_IPC_DATA(FIO_BUF_INFO2(chunk, (size_t)len)),
                  .done = (i == 4));  /* Last chunk sets done=1 */
  }
}

/* Worker receives each chunk */
void on_chunk(fio_ipc_s *msg) {
  printf("Received chunk: %.*s\n", (int)msg->len, msg->data);
}

/* Worker notified when streaming complete */
void on_stream_done(fio_ipc_s *msg) {
  printf("Stream complete\n");
  (void)msg;
}

void request_stream(void) {
  fio_ipc_call(.call = stream_handler,
               .on_reply = on_chunk,
               .on_done = on_stream_done,
               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)"start_stream")));
}
```

#### Excluding Self from Broadcast

```c
#define FIO_IPC
#include FIO_INCLUDE_FILE

void notify_handler(fio_ipc_s *msg) {
  printf("[%d] Notification: %.*s\n", fio_io_pid(), (int)msg->len, msg->data);
}

/* Method 1: Use .others = true */
void notify_others_method1(const char *data) {
  fio_ipc_local(.others = true,
                .call = notify_handler,
                .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
}

/* Method 2: Set ipc->from = FIO_IPC_EXCLUDE_SELF before sending */
void notify_others_method2(const char *data) {
  fio_ipc_s *msg = fio_ipc_new(.workers = 1,
                               .call = notify_handler,
                               .data = FIO_IPC_DATA(FIO_BUF_INFO1((char *)data)));
  msg->from = FIO_IPC_EXCLUDE_SELF;
  fio_ipc_send(msg);
}
```

### Security

All IPC messages are encrypted using ChaCha20-Poly1305 AEAD (Authenticated Encryption with Associated Data):

- **Encrypted fields**: `call`/`opcode`, `on_reply`, `on_done`, `udata`, and `data`
- **Authenticated (AAD)**: `len`, `flags`, `private_flags`
- **Nonce**: Derived from `timestamp` and `id` fields
- **Key**: Derived from the process secret (set at startup)

The encryption ensures:

1. **Confidentiality**: Message contents cannot be read by external processes
2. **Integrity**: Any tampering is detected and the message is rejected
3. **Authentication**: Only processes with the shared secret can communicate

**Note**: If decryption fails (e.g., due to tampering), a security log message is emitted and the message is discarded.

### Thread Safety

- `fio_ipc_call`, `fio_ipc_reply`, `fio_ipc_local`, `fio_ipc_cluster`, and `fio_ipc_broadcast` are thread-safe and can be called from any thread
- Operations are deferred to the IO thread for actual processing
- Message reference counting (`fio_ipc_dup`/`fio_ipc_free`) is thread-safe

### Memory Management

- Messages are reference-counted using the `FIO_REF` mechanism
- Messages passed to callbacks are automatically freed after the callback returns
- Use `fio_ipc_dup` to retain a message beyond the callback lifetime
- Every `fio_ipc_dup` must be matched with `fio_ipc_free`
- Data buffers passed to `FIO_IPC_DATA` are copied synchronously - they can be freed immediately after the call

------------------------------------------------------------
