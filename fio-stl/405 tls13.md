## TLS 1.3 IO Integration

```c
#define FIO_IO
#include "fio-stl/include.h"
```

The TLS 1.3 IO module provides seamless integration between the native TLS 1.3 implementation and the facil.io IO reactor. When OpenSSL is not available, this module automatically registers as the default TLS implementation.

**Note**: This module is automatically included when `FIO_IO` is defined and `FIO_TLS13` is available. It requires the TLS 1.3 module (`190 tls13.h`) and the IO reactor module (`400 io.h`).

------------------------------------------------------------

### Overview

The TLS 1.3 IO integration provides:

- **Drop-in TLS support** - Works with existing `fio_io_tls_s` configuration
- **Automatic fallback** - Used when OpenSSL is not available
- **Self-signed certificates** - Automatic generation for development/testing
- **PEM file loading** - Load certificates and keys from PEM files
- **ALPN support** - Application-Layer Protocol Negotiation
- **Non-blocking I/O** - Seamless integration with the event-driven reactor

### Conditional Compilation

The TLS 1.3 IO module compiles when:

- `FIO_IO` is defined (the IO reactor module is included)
- `FIO_TLS13` is defined (the TLS 1.3 module is included)
- `FIO_NO_TLS` is **not** defined

When OpenSSL is not detected (`HAVE_OPENSSL` not defined and `openssl/ssl.h` not found), the TLS 1.3 module automatically registers as the default TLS implementation.

------------------------------------------------------------

### Features

#### Self-Signed Certificates

When no certificate is configured for a server, the module automatically generates a self-signed certificate:

| Property | Value |
|----------|-------|
| Algorithm | ECDSA with P-256 curve |
| Security Level | 128-bit (equivalent to RSA-3072) |
| Signature | SHA-256 |
| Key Generation | ~10ms (vs ~2000ms for RSA-4096) |

**Note**: Self-signed certificates are intended for development and testing only. Use properly issued certificates from a trusted Certificate Authority (CA) in production.

#### Certificate Loading

The module supports loading certificates and private keys from PEM files:

- **P-256 ECDSA** - 32-byte private key scalar
- **Ed25519** - 32-byte private key seed
- **RSA** - Not yet supported for signing (verification only)

#### ALPN Protocol Negotiation

Application-Layer Protocol Negotiation (RFC 7301) is supported for:

- HTTP/2 (`h2`)
- HTTP/1.1 (`http/1.1`)
- Custom protocols

------------------------------------------------------------

### Usage with the IO Reactor

The TLS 1.3 module integrates with the IO system through the `fio_io_tls_s` configuration object:

```c
#define FIO_IO
#include "fio-stl.h"

/* Create a TLS configuration object */
fio_io_tls_s *tls = fio_io_tls_new();

/* Optional: load certificates from PEM files */
fio_io_tls_cert_add(tls,
                    "www.example.com",  /* server name (SNI) */
                    "cert.pem",         /* public certificate */
                    "key.pem",          /* private key */
                    NULL);              /* password (if key is encrypted) */

/* Optional: configure ALPN protocol negotiation */
fio_io_tls_alpn_add(tls, "h2", on_http2_selected);
fio_io_tls_alpn_add(tls, "http/1.1", on_http1_selected);

/* Start listening with TLS */
fio_io_listen(.url = "0.0.0.0:443",
              .protocol = &MY_PROTOCOL,
              .tls = tls);

/* The TLS object can be freed after fio_io_listen (it's reference counted) */
fio_io_tls_free(tls);

/* Start the IO reactor */
fio_io_start(0);
```

------------------------------------------------------------

### HTTPS Server Example

A complete example of an HTTPS server using the native TLS 1.3 implementation:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

/* Protocol callbacks */
FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[1024];
  size_t len = fio_io_read(io, buf, sizeof(buf));
  if (len) {
    /* Echo back with HTTP response */
    const char response[] = 
        "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Content-Length: 13\r\n"
        "Connection: close\r\n"
        "\r\n"
        "Hello, TLS!\n";
    fio_io_write(io, response, sizeof(response) - 1);
    fio_io_close(io);
  }
}

fio_io_protocol_s HTTPS_PROTOCOL = {
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context - will use self-signed certificate */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* For production, load real certificates:
   * fio_io_tls_cert_add(tls, "example.com", "cert.pem", "key.pem", NULL);
   */
  
  fio_io_listen(.url = "0.0.0.0:8443",
                .protocol = &HTTPS_PROTOCOL,
                .tls = tls);
  
  fio_io_tls_free(tls);
  
  FIO_LOG_INFO("HTTPS server listening on port 8443");
  FIO_LOG_INFO("Test with: curl -k https://localhost:8443/");
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### TLS Client Example

Using TLS 1.3 for outgoing connections:

```c
#define FIO_LOG
#define FIO_IO
#include "fio-stl.h"

FIO_SFUNC void on_connect(fio_io_s *io) {
  FIO_LOG_INFO("TLS connection established!");
  
  /* Send HTTP request */
  const char request[] = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
  fio_io_write(io, request, sizeof(request) - 1);
}

FIO_SFUNC void on_data(fio_io_s *io) {
  char buf[4096];
  size_t len = fio_io_read(io, buf, sizeof(buf) - 1);
  if (len) {
    buf[len] = '\0';
    FIO_LOG_INFO("Received: %s", buf);
    fio_io_close(io);
  }
}

fio_io_protocol_s CLIENT_PROTOCOL = {
    .on_attach = on_connect,
    .on_data = on_data,
    .on_timeout = fio_io_touch,
};

int main(void) {
  /* Create TLS context for client */
  fio_io_tls_s *tls = fio_io_tls_new();
  
  /* Add server name for SNI */
  fio_io_tls_cert_add(tls, "example.com", NULL, NULL, NULL);
  
  /* Connect with TLS */
  fio_io_connect(.url = "example.com:443",
                 .protocol = &CLIENT_PROTOCOL,
                 .tls = tls);
  
  fio_io_tls_free(tls);
  
  fio_io_start(0);
  return 0;
}
```

------------------------------------------------------------

### API Reference

#### `fio_tls13_io_functions`

```c
fio_io_functions_s fio_tls13_io_functions(void);
```

Returns the TLS 1.3 IO functions structure for TLS operations.

This function is called automatically during module initialization to register TLS 1.3 as the default TLS implementation (when OpenSSL is not available). You typically don't need to call this directly.

**Returns:** A `fio_io_functions_s` structure containing:

| Function | Purpose |
|----------|---------|
| `build_context` | Creates TLS context from `fio_io_tls_s` configuration |
| `free_context` | Frees the TLS context and associated resources |
| `start` | Initializes TLS for a new connection |
| `read` | Non-blocking TLS read (decryption) |
| `write` | Non-blocking TLS write (encryption) |
| `flush` | Flushes pending handshake data |
| `finish` | Sends close_notify alert |
| `cleanup` | Frees per-connection TLS state |

------------------------------------------------------------

### TLS Configuration Functions

The following functions from the IO module are used to configure TLS. See the [IO Reactor documentation](400%20io.md) for complete details.

#### `fio_io_tls_new`

```c
fio_io_tls_s *fio_io_tls_new(void);
```

Creates a new TLS configuration object.

#### `fio_io_tls_free`

```c
void fio_io_tls_free(fio_io_tls_s *tls);
```

Frees a TLS configuration object (reference counted).

#### `fio_io_tls_cert_add`

```c
fio_io_tls_s *fio_io_tls_cert_add(fio_io_tls_s *tls,
                                  const char *server_name,
                                  const char *public_cert_file,
                                  const char *private_key_file,
                                  const char *pk_password);
```

Adds a certificate to the TLS context.

**Parameters:**
- `server_name` - The server name for SNI matching (client) or certificate selection (server)
- `public_cert_file` - Path to PEM-encoded certificate (or NULL for self-signed)
- `private_key_file` - Path to PEM-encoded private key (or NULL for self-signed)
- `pk_password` - Password for encrypted private keys (or NULL)

**Supported key types:**
- P-256 ECDSA (recommended)
- Ed25519

#### `fio_io_tls_alpn_add`

```c
fio_io_tls_s *fio_io_tls_alpn_add(fio_io_tls_s *tls,
                                  const char *protocol_name,
                                  void (*on_selected)(fio_io_s *));
```

Registers an ALPN protocol and its selection callback.

**Parameters:**
- `protocol_name` - Protocol identifier (e.g., "h2", "http/1.1")
- `on_selected` - Callback invoked when this protocol is negotiated

The first protocol added is the preferred/default protocol.

------------------------------------------------------------

### Internal Architecture

The TLS 1.3 IO integration uses a layered architecture:

```
┌─────────────────────────────────────┐
│         Application Layer           │
│    (fio_io_read, fio_io_write)      │
├─────────────────────────────────────┤
│         IO Reactor Layer            │
│    (fio_io_functions_s callbacks)   │
├─────────────────────────────────────┤
│      TLS 1.3 IO Integration         │
│    (fio___tls13_read/write)         │
├─────────────────────────────────────┤
│       TLS 1.3 Record Layer          │
│  (fio_tls13_record_encrypt/decrypt) │
├─────────────────────────────────────┤
│        AEAD Cipher Layer            │
│   (AES-GCM, ChaCha20-Poly1305)      │
├─────────────────────────────────────┤
│          Socket Layer               │
│     (fio_sock_read/write)           │
└─────────────────────────────────────┘
```

#### Connection State

Each TLS connection maintains:

| Buffer | Purpose | Size |
|--------|---------|------|
| `recv_buf` | Incoming encrypted data | ~17KB |
| `app_buf` | Decrypted application data | 16KB |
| `send_buf` | Outgoing handshake data | 8KB |
| `enc_buf` | Pre-allocated encryption buffer | ~17KB |

#### Handshake Flow

**Server:**
1. `start` - Initialize server state, wait for ClientHello
2. `read` - Receive ClientHello, send ServerHello..Finished
3. `read` - Receive client Finished
4. Connection established

**Client:**
1. `start` - Initialize client state, send ClientHello
2. `read` - Receive ServerHello..Finished, send client Finished
3. Connection established

------------------------------------------------------------

### Security Considerations

#### Certificate Verification

- **Server Mode**: Certificate verification is typically not enabled (clients don't usually present certificates)
- **Client Mode**: By default, certificate verification is **skipped** with a warning logged

To enable certificate verification for client connections, a trust store must be configured (not yet exposed through the IO API).

#### Production Recommendations

1. **Use Real Certificates**: Obtain certificates from a trusted CA (e.g., Let's Encrypt)
2. **Avoid Self-Signed**: Self-signed certificates should only be used for development
3. **Keep Updated**: Security patches may be released for the TLS implementation
4. **Protect Private Keys**: Use appropriate file permissions

#### Memory Safety

- All sensitive key material is zeroed on cleanup using `fio_secure_zero`
- Connection state is properly freed on close
- Buffer overflows are prevented by size checks

------------------------------------------------------------

### Comparison with OpenSSL

| Feature | TLS 1.3 Native | OpenSSL |
|---------|----------------|---------|
| Dependencies | None | OpenSSL 3.x |
| Binary Size | Smaller | Larger |
| TLS Versions | 1.3 only | 1.0-1.3 |
| Cipher Suites | 3 (TLS 1.3) | Many |
| Certificate Types | P-256, Ed25519 | All |
| Session Resumption | Not yet | Yes |
| 0-RTT | Not yet | Yes |
| OCSP Stapling | No | Yes |
| Client Certificates | Yes | Yes |

**When to use TLS 1.3 Native:**
- Minimal dependencies required
- Only TLS 1.3 clients expected
- Embedded or resource-constrained environments

**When to use OpenSSL:**
- Legacy TLS version support needed
- Full certificate type support required
- Session resumption important
- OCSP stapling required

------------------------------------------------------------

### Error Handling

TLS errors are logged using the facil.io logging system:

| Log Level | Purpose |
|-----------|---------|
| `FIO_LOG_ERROR` | Critical failures (certificate loading, key generation) |
| `FIO_LOG_WARNING` | Non-fatal issues (trust store loading) |
| `FIO_LOG_DEBUG2` | Detailed debugging information |

Connection errors result in the connection being closed with an appropriate TLS alert.

------------------------------------------------------------

### Memory Management

- **Context** (`fio___tls13_context_s`): Shared across connections, reference counted
- **Connection** (`fio___tls13_connection_s`): Per-connection, freed on close
- **Certificates**: Copied to context, freed with context
- **Self-signed key**: Global, freed at program exit

Leak counters are enabled in debug builds to detect memory leaks.

------------------------------------------------------------
