## ED25519 & X25519

```c
#define FIO_ED25519
#include "fio-stl.h"
```

This module provides elliptic curve cryptography using Curve25519, offering both digital signatures (Ed25519) and key exchange (X25519) with 128-bit security level. These are the minimal building blocks for secure inter-machine communication.

**Note:** this implementation has not been audited. Use at your own risk. A tested cryptographic library (e.g., OpenSSL) is preferred when available.

**Note:** this module depends on the `FIO_SHA2` module which will be automatically included.

### Ed25519 Digital Signatures

Ed25519 provides fast, secure digital signatures.

- Secret key: 32 bytes
- Public key: 32 bytes
- Signature: 64 bytes

#### `fio_ed25519_keypair`

```c
void fio_ed25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);
```

Generates a new random Ed25519 key pair.

The secret key must be kept secret and securely erased when no longer needed. The public key can be freely shared.

#### `fio_ed25519_public_key`

```c
void fio_ed25519_public_key(uint8_t public_key[32],
                            const uint8_t secret_key[32]);
```

Derives the public key from an Ed25519 secret key.

Useful when the secret key is loaded from storage and the public key needs to be recomputed.

#### `fio_ed25519_sign`

```c
void fio_ed25519_sign(uint8_t signature[64],
                      const void *message,
                      size_t len,
                      const uint8_t secret_key[32],
                      const uint8_t public_key[32]);
```

Signs a message using Ed25519.

* `signature`   MUST point to a 64 byte buffer for the output signature.
* `message`     the message to sign (may be NULL if `len` is 0).
* `len`         the length of the message in bytes.
* `secret_key`  MUST point to a 32 byte secret key.
* `public_key`  MUST point to a 32 byte public key.

The signature is deterministic (same message + key = same signature).

#### `fio_ed25519_verify`

```c
int fio_ed25519_verify(const uint8_t signature[64],
                       const void *message,
                       size_t len,
                       const uint8_t public_key[32]);
```

Verifies an Ed25519 signature.

* `signature`   MUST point to a 64 byte signature.
* `message`     the message that was signed.
* `len`         the length of the message in bytes.
* `public_key`  MUST point to a 32 byte public key.

Returns `0` on success (valid signature), `-1` on failure (invalid signature).

### X25519 Key Exchange (ECDH)

X25519 provides Elliptic Curve Diffie-Hellman key exchange. Two parties can derive a shared secret using their secret key and the other party's public key.

- Secret key: 32 bytes
- Public key: 32 bytes
- Shared secret: 32 bytes

#### `fio_x25519_keypair`

```c
void fio_x25519_keypair(uint8_t secret_key[32], uint8_t public_key[32]);
```

Generates a new random X25519 key pair.

The secret key must be kept secret. The public key can be shared with the other party for key exchange.

#### `fio_x25519_public_key`

```c
void fio_x25519_public_key(uint8_t public_key[32],
                           const uint8_t secret_key[32]);
```

Derives the public key from an X25519 secret key.

This performs scalar multiplication of the secret key with the base point.

#### `fio_x25519_shared_secret`

```c
int fio_x25519_shared_secret(uint8_t shared_secret[32],
                             const uint8_t secret_key[32],
                             const uint8_t their_public_key[32]);
```

Computes a shared secret using X25519 (ECDH).

Both parties compute the same shared secret:

```c
shared = X25519(my_secret, their_public)
```

* `shared_secret`    MUST point to a 32 byte buffer for the output.
* `secret_key`       MUST point to your 32 byte secret key.
* `their_public_key` MUST point to the other party's 32 byte public key.

Returns `0` on success, `-1` on failure (e.g., if `their_public_key` is a low-order point, which would result in an all-zero shared secret).

**Note:** the shared secret should be passed through a KDF (e.g., HKDF with SHA-256) before being used as an encryption key.

### Key Conversion

Ed25519 and X25519 use the same underlying curve but with different representations. These functions convert between the two formats, allowing a single key pair to be used for both signing and encryption.

**Note:** converting keys is generally safe, but using the same key for both signing and encryption is debated. Consider using separate key pairs for maximum security.

#### `fio_ed25519_sk_to_x25519`

```c
void fio_ed25519_sk_to_x25519(uint8_t x_secret_key[32],
                              const uint8_t ed_secret_key[32]);
```

Converts an Ed25519 secret key to an X25519 secret key.

This allows using an Ed25519 signing key for X25519 key exchange.

#### `fio_ed25519_pk_to_x25519`

```c
void fio_ed25519_pk_to_x25519(uint8_t x_public_key[32],
                              const uint8_t ed_public_key[32]);
```

Converts an Ed25519 public key to an X25519 public key.

This allows encrypting to someone who has only shared their Ed25519 signing public key.

### Public Key Encryption (ECIES)

This provides asymmetric encryption where anyone can encrypt a message using only the recipient's public key, and only the recipient can decrypt it using their private key. No prior key exchange or handshake is required.

The scheme uses:
- X25519 for ephemeral key agreement
- SHA-256 for key derivation
- ChaCha20-Poly1305 or AES256-GCM for authenticated encryption

Ciphertext format: `[32-byte ephemeral public key][16-byte MAC][encrypted data]`

Total overhead: 48 bytes

#### `FIO_X25519_CIPHERTEXT_LEN`

```c
#define FIO_X25519_CIPHERTEXT_LEN(message_len) ((message_len) + 48)
```

Returns the ciphertext length for a given plaintext length.

Ciphertext = ephemeral_pk (32) + mac (16) + encrypted_message (message_len)

#### `FIO_X25519_PLAINTEXT_LEN`

```c
#define FIO_X25519_PLAINTEXT_LEN(ciphertext_len) \
  ((ciphertext_len) > 48 ? ((ciphertext_len) - 48) : 0)
```

Returns the plaintext length for a given ciphertext length.

Returns `0` if `ciphertext_len < 48` (invalid ciphertext).

#### `fio_x25519_encrypt`

```c
int fio_x25519_encrypt(uint8_t *ciphertext,
                       const void *message,
                       size_t message_len,
                       fio_crypto_enc_fn encryption_function,
                       const uint8_t recipient_pk[32]);
```

Encrypts a message using the recipient's X25519 public key.

* `ciphertext`          MUST point to a buffer of at least `message_len + 48` bytes.
* `message`             the plaintext message to encrypt.
* `message_len`         the length of the message in bytes.
* `encryption_function` the encryption function (e.g., `fio_chacha20_poly1305_enc`).
* `recipient_pk`        MUST point to the recipient's 32 byte X25519 public key.

The ciphertext includes:
- 32 bytes: ephemeral public key (for key agreement)
- 16 bytes: authentication tag (MAC)
- N bytes: encrypted message

Returns `0` on success, `-1` on failure.

#### `fio_x25519_decrypt`

```c
int fio_x25519_decrypt(uint8_t *plaintext,
                       const uint8_t *ciphertext,
                       size_t ciphertext_len,
                       fio_crypto_dec_fn decryption_function,
                       const uint8_t recipient_sk[32]);
```

Decrypts a message using the recipient's X25519 secret key.

* `plaintext`           MUST point to a buffer of at least `ciphertext_len - 48` bytes.
* `ciphertext`          the ciphertext (ephemeral_pk || mac || encrypted_data).
* `ciphertext_len`      the length of the ciphertext (must be >= 48).
* `decryption_function` the decryption function (e.g., `fio_chacha20_poly1305_dec`).
* `recipient_sk`        MUST point to the recipient's 32 byte X25519 secret key.

Returns `0` on success, `-1` on failure (authentication failed or invalid input).

------------------------------------------------------------
