## PEM Parser

```c
#define FIO_PEM
#include FIO_INCLUDE_FILE
```

By defining `FIO_PEM`, the PEM file parser module is defined and made available. This module provides parsing of PEM-encoded files as defined in [RFC 7468](https://tools.ietf.org/html/rfc7468), commonly used for X.509 certificates and private keys in TLS.

PEM (Privacy-Enhanced Mail) format wraps binary DER-encoded data in Base64 with distinctive header and footer lines:

```
-----BEGIN <label>-----
<base64-encoded DER data>
-----END <label>-----
```

The module supports:

- **Generic PEM parsing** - extract and Base64-decode any PEM block by label
- **Certificate extraction** - parse `CERTIFICATE` labeled blocks, with optional X.509 structure parsing
- **Private key parsing** - decode private keys from multiple formats:
  - PKCS#8 `PRIVATE KEY` (RSA, ECDSA P-256, Ed25519)
  - PKCS#1 `RSA PRIVATE KEY` (legacy RSA)
  - SEC1 `EC PRIVATE KEY` (legacy EC)
- **Secure cleanup** - zero sensitive key material after use

**Note**: this module depends on the Base64 string utilities (always available). Certificate structure parsing requires the X.509 module (`FIO_X509`), and private key parsing requires the ASN.1 module (`FIO_ASN1`). The generic `fio_pem_parse` function works without these dependencies.

**Note**: encrypted private keys are not supported.

### PEM Types

#### `fio_pem_key_type_e`

```c
typedef enum {
  FIO_PEM_KEY_UNKNOWN = 0,    /* Unknown or unsupported key type */
  FIO_PEM_KEY_RSA = 1,        /* RSA private key */
  FIO_PEM_KEY_ECDSA_P256 = 2, /* ECDSA P-256 (secp256r1) private key */
  FIO_PEM_KEY_ED25519 = 3,    /* Ed25519 private key */
} fio_pem_key_type_e;
```

Identifies the algorithm type of a parsed private key.

#### `fio_pem_s`

```c
typedef struct {
  const uint8_t *der; /* Pointer to decoded DER data */
  size_t der_len;     /* Length of DER data */
  const char *label;  /* PEM label (e.g., "CERTIFICATE", "PRIVATE KEY") */
  size_t label_len;   /* Length of label */
} fio_pem_s;
```

Represents a single parsed PEM block. Returned by `fio_pem_parse` after locating and Base64-decoding one PEM entity.

**Members:**
- `der` - pointer to the decoded DER (binary) data; points into the caller-provided `der_buf`
- `der_len` - length of the decoded DER data in bytes
- `label` - pointer to the PEM label string (e.g., `"CERTIFICATE"`); points into the original PEM input data
- `label_len` - length of the label string in bytes (not NUL-terminated)

**Note**: the `label` pointer refers directly into the original `pem_data` buffer. The `der` pointer refers into the caller-provided decode buffer. Both become invalid if their respective buffers are freed.

#### `fio_pem_private_key_s`

```c
typedef struct {
  fio_pem_key_type_e type;
  union {
    struct {
      const uint8_t *n; /* RSA modulus (big-endian) */
      size_t n_len;
      const uint8_t *e; /* RSA public exponent (big-endian) */
      size_t e_len;
      const uint8_t *d; /* RSA private exponent (big-endian) */
      size_t d_len;
      const uint8_t *p; /* RSA prime p (optional) */
      size_t p_len;
      const uint8_t *q; /* RSA prime q (optional) */
      size_t q_len;
    } rsa;
    struct {
      uint8_t private_key[32]; /* P-256 scalar (32 bytes) */
      uint8_t public_key[65];  /* Uncompressed point (optional) */
      int has_public_key;      /* 1 if public_key is populated */
    } ecdsa_p256;
    struct {
      uint8_t private_key[32]; /* Ed25519 seed (32 bytes) */
      uint8_t public_key[32];  /* Ed25519 public key (optional) */
      int has_public_key;      /* 1 if public_key is populated */
    } ed25519;
  };
} fio_pem_private_key_s;
```

Holds the parsed components of a private key. The `type` field determines which union member is active.

**Members:**
- `type` - the key algorithm type (`fio_pem_key_type_e`)

**RSA members** (`key.rsa.*`, when `type == FIO_PEM_KEY_RSA`):
- `n` / `n_len` - RSA modulus, big-endian (leading zero byte stripped)
- `e` / `e_len` - RSA public exponent, big-endian
- `d` / `d_len` - RSA private exponent, big-endian
- `p` / `p_len` - first prime factor (optional, may be NULL)
- `q` / `q_len` - second prime factor (optional, may be NULL)

**ECDSA P-256 members** (`key.ecdsa_p256.*`, when `type == FIO_PEM_KEY_ECDSA_P256`):
- `private_key` - 32-byte P-256 scalar
- `public_key` - 65-byte uncompressed point (`0x04 || X || Y`), valid only if `has_public_key` is 1
- `has_public_key` - 1 if the public key was present in the PEM data, 0 otherwise

**Ed25519 members** (`key.ed25519.*`, when `type == FIO_PEM_KEY_ED25519`):
- `private_key` - 32-byte Ed25519 seed
- `public_key` - 32-byte Ed25519 public key, valid only if `has_public_key` is 1
- `has_public_key` - 1 if the public key was present in the PEM data, 0 otherwise

**Note**: for RSA keys, the `n`, `e`, `d`, `p`, and `q` pointers reference data inside a temporary DER buffer allocated during parsing. These pointers become invalid after `fio_pem_parse_private_key` returns, so copy any data you need before the structure goes out of scope. For ECDSA and Ed25519 keys, the key bytes are copied into the structure and remain valid.

**Note**: call `fio_pem_private_key_clear` when done to securely zero sensitive key material.

### PEM Functions

#### `fio_pem_parse`

```c
size_t fio_pem_parse(fio_pem_s *out,
                     uint8_t *der_buf,
                     size_t der_buf_len,
                     const char *pem_data,
                     size_t pem_len);
```

Parses a single PEM block from `pem_data`.

Locates the next `-----BEGIN <label>-----` / `-----END <label>-----` pair, Base64-decodes the content between them, and writes the decoded DER data into `der_buf`. The resulting label and DER pointers are stored in `out`.

**Parameters:**
- `out` - output structure filled with parsed PEM block information
- `der_buf` - caller-provided buffer to store decoded DER data
- `der_buf_len` - size of `der_buf` in bytes
- `pem_data` - pointer to PEM-encoded input data
- `pem_len` - length of the PEM input data in bytes

**Returns:** the number of bytes consumed from `pem_data` (including the end marker and trailing newlines), or 0 on error (no PEM block found, decode failure, or buffer too small).

**Note**: to parse multiple PEM blocks from a single file, advance `pem_data` by the returned byte count and reduce `pem_len` accordingly, calling `fio_pem_parse` in a loop until it returns 0.

#### `fio_pem_parse_certificate`

```c
int fio_pem_parse_certificate(fio_x509_cert_s *cert,
                              const char *pem_data,
                              size_t pem_len);
```

Parses a PEM-encoded X.509 certificate and fills the `cert` structure.

Locates a `CERTIFICATE` labeled PEM block, Base64-decodes it, and parses the resulting DER as an X.509 certificate using `fio_x509_parse`.

**Parameters:**
- `cert` - output X.509 certificate structure (defined in the X.509 module)
- `pem_data` - PEM-encoded certificate data
- `pem_len` - length of the PEM data in bytes

**Returns:** 0 on success, -1 on error (no certificate found, wrong label, decode failure, or X.509 parse failure).

**Note**: requires the X.509 module (`FIO_X509`). Returns -1 if the X.509 module is not available.

**Note**: on success, the `cert` structure may contain pointers into an internally allocated DER buffer. The caller must manage the lifetime of the certificate data accordingly.

#### `fio_pem_get_certificate_der`

```c
size_t fio_pem_get_certificate_der(uint8_t *der_out,
                                   size_t der_out_len,
                                   const char *pem_data,
                                   size_t pem_len);
```

Extracts the raw DER-encoded certificate bytes from PEM data without parsing the X.509 structure.

This is a convenience function that locates a `CERTIFICATE` labeled PEM block, Base64-decodes it, and writes the binary DER data to `der_out`.

**Parameters:**
- `der_out` - output buffer for the decoded DER data
- `der_out_len` - size of the output buffer in bytes
- `pem_data` - PEM-encoded certificate data
- `pem_len` - length of the PEM data in bytes

**Returns:** the number of DER bytes written to `der_out`, or 0 on error (no certificate found, wrong label, buffer too small, or decode failure).

**Note**: unlike `fio_pem_parse_certificate`, this function does not require the X.509 module and does not parse the certificate structure.

#### `fio_pem_parse_private_key`

```c
int fio_pem_parse_private_key(fio_pem_private_key_s *key,
                              const char *pem_data,
                              size_t pem_len);
```

Parses a PEM-encoded private key and fills the `key` structure.

Dispatches to the appropriate parser based on the PEM label:

| PEM Label | Format | Supported Key Types |
|-----------|--------|---------------------|
| `PRIVATE KEY` | PKCS#8 (RFC 5958) | RSA, ECDSA P-256, Ed25519 |
| `RSA PRIVATE KEY` | PKCS#1 | RSA |
| `EC PRIVATE KEY` | SEC1 | ECDSA P-256 |

**Parameters:**
- `key` - output private key structure
- `pem_data` - PEM-encoded private key data
- `pem_len` - length of the PEM data in bytes

**Returns:** 0 on success, -1 on error (unsupported label, unsupported algorithm/curve, parse failure, or missing ASN.1 module).

**Note**: requires the ASN.1 module (`FIO_ASN1`) for key structure parsing. Returns -1 if the ASN.1 module is not available.

**Note**: on failure, the `key` structure is securely zeroed. On success, call `fio_pem_private_key_clear` when done to securely zero sensitive key material.

**Note**: for RSA keys parsed from PKCS#8 or PKCS#1, the internal pointers (`n`, `e`, `d`, `p`, `q`) reference a temporary DER buffer that is freed before this function returns. Copy any needed data immediately.

#### `fio_pem_private_key_clear`

```c
void fio_pem_private_key_clear(fio_pem_private_key_s *key);
```

Securely clears a private key structure by overwriting all memory with zeros using `fio_secure_zero`.

**Parameters:**
- `key` - pointer to the private key structure to clear (safe to pass NULL)

**Note**: always call this function when a `fio_pem_private_key_s` is no longer needed, especially for ECDSA and Ed25519 keys whose scalar bytes are stored directly in the structure.

### PEM Examples

#### Parsing a PEM Certificate (DER Extraction)

```c
#define FIO_PEM
#include FIO_INCLUDE_FILE

void example_get_cert_der(const char *pem_data, size_t pem_len) {
  uint8_t der_buf[4096];
  size_t der_len = fio_pem_get_certificate_der(
      der_buf, sizeof(der_buf), pem_data, pem_len);
  if (der_len == 0) {
    /* Error: no valid certificate found */
    return;
  }
  /* der_buf[0..der_len-1] contains the raw DER certificate */
}
```

#### Parsing Multiple PEM Blocks

```c
void example_parse_all_blocks(const char *pem_data, size_t pem_len) {
  uint8_t der_buf[8192];
  fio_pem_s pem;
  size_t offset = 0;

  while (offset < pem_len) {
    size_t consumed = fio_pem_parse(
        &pem, der_buf, sizeof(der_buf),
        pem_data + offset, pem_len - offset);
    if (consumed == 0)
      break;

    printf("Found PEM block: %.*s (%zu bytes DER)\n",
           (int)pem.label_len, pem.label, pem.der_len);
    offset += consumed;
  }
}
```

#### Parsing a Private Key

```c
void example_parse_key(const char *pem_data, size_t pem_len) {
  fio_pem_private_key_s key;
  if (fio_pem_parse_private_key(&key, pem_data, pem_len) != 0) {
    /* Error: unsupported or malformed key */
    return;
  }

  switch (key.type) {
  case FIO_PEM_KEY_RSA:
    printf("RSA key: modulus %zu bytes\n", key.rsa.n_len);
    break;
  case FIO_PEM_KEY_ECDSA_P256:
    printf("ECDSA P-256 key (public key %s)\n",
           key.ecdsa_p256.has_public_key ? "present" : "absent");
    break;
  case FIO_PEM_KEY_ED25519:
    printf("Ed25519 key (public key %s)\n",
           key.ed25519.has_public_key ? "present" : "absent");
    break;
  default:
    break;
  }

  /* Securely clear key material when done */
  fio_pem_private_key_clear(&key);
}
```

### Supported Key Formats

| PEM Label | Standard | Key Types | Notes |
|-----------|----------|-----------|-------|
| `PRIVATE KEY` | PKCS#8 (RFC 5958) | RSA, ECDSA P-256, Ed25519 | Recommended modern format |
| `RSA PRIVATE KEY` | PKCS#1 (RFC 8017) | RSA only | Legacy format |
| `EC PRIVATE KEY` | SEC1 (RFC 5915) | ECDSA P-256 only | Legacy format; curve detected by 32-byte key length |
| `CERTIFICATE` | X.509 (RFC 5280) | N/A | Certificate parsing, not key |

------------------------------------------------------------
