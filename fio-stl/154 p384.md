## ECDSA P-384 (secp384r1)

```c
#define FIO_P384
#include FIO_INCLUDE_FILE
```

By defining `FIO_P384`, the ECDSA P-384 signature verification functions are defined and made available. This module provides elliptic curve signature verification for the NIST P-384 curve (also known as secp384r1).

P-384 is a widely-used elliptic curve standardized in [NIST FIPS 186-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf). It is the curve behind ECDSA signatures in TLS 1.3 certificate chains, including Let's Encrypt root CAs.

The module provides:

- **DER signature verification** - verify ECDSA signatures in standard DER encoding with uncompressed public keys
- **Raw signature verification** - verify ECDSA signatures given raw (r, s) components and public key coordinates

Curve parameters (NIST FIPS 186-4):

| Parameter | Value |
|-----------|-------|
| Prime p | 2^384 − 2^128 − 2^96 + 2^32 − 1 |
| Curve equation | y² = x³ − 3x + b (mod p) |
| Security level | ~192-bit |
| Coordinate size | 48 bytes |

**Note**: this implementation has not been audited. Use at your own risk. The scalar multiplication is not constant-time, making it suitable for signature **verification** but not for signing or key generation.

### ECDSA P-384 Verification Functions

#### `fio_ecdsa_p384_verify`

```c
int fio_ecdsa_p384_verify(const uint8_t *sig,
                          size_t sig_len,
                          const uint8_t *msg_hash,
                          const uint8_t *pubkey,
                          size_t pubkey_len);
```

Verifies an ECDSA P-384 signature over a message hash using a DER-encoded signature and an uncompressed public key.

This is the high-level verification function. It parses the DER-encoded signature, extracts the (r, s) components, validates the uncompressed public key format, and delegates to `fio_ecdsa_p384_verify_raw`.

**Parameters:**
- `sig` - DER-encoded signature (`SEQUENCE { r INTEGER, s INTEGER }`)
- `sig_len` - length of the signature in bytes
- `msg_hash` - SHA-384 hash of the message (48 bytes)
- `pubkey` - uncompressed public key (97 bytes: `0x04 || x || y`)
- `pubkey_len` - length of the public key (must be 97)

**Returns:** `0` on success (valid signature), `-1` on failure (invalid signature, malformed input, or NULL parameters).

**Note**: the public key must be in uncompressed format, starting with the `0x04` prefix byte followed by the 48-byte x-coordinate and 48-byte y-coordinate. Compressed public keys are not supported.

#### `fio_ecdsa_p384_verify_raw`

```c
int fio_ecdsa_p384_verify_raw(const uint8_t r[48],
                              const uint8_t s[48],
                              const uint8_t msg_hash[48],
                              const uint8_t pubkey_x[48],
                              const uint8_t pubkey_y[48]);
```

Verifies an ECDSA P-384 signature using raw (r, s) values and separate public key coordinates.

This is the low-level verification function. It performs the full ECDSA verification algorithm:

1. Validates that r and s are in the range [1, n−1]
2. Verifies the public key point lies on the P-384 curve
3. Computes w = s⁻¹ mod n
4. Computes u1 = e·w mod n, u2 = r·w mod n (where e is the message hash)
5. Computes R = u1·G + u2·Q using Shamir's trick for efficiency
6. Verifies that R.x mod n equals r

**Parameters:**
- `r` - the r component of the signature (48 bytes, big-endian)
- `s` - the s component of the signature (48 bytes, big-endian)
- `msg_hash` - SHA-384 hash of the message (48 bytes, big-endian)
- `pubkey_x` - x-coordinate of the public key (48 bytes, big-endian)
- `pubkey_y` - y-coordinate of the public key (48 bytes, big-endian)

**Returns:** `0` on success (valid signature), `-1` on failure (invalid signature or parameters out of range).

**Note**: all byte arrays are in big-endian format (most significant byte first), which is the standard encoding for ECDSA parameters.

### ECDSA P-384 Examples

#### DER Signature Verification (TLS Certificate)

```c
#define FIO_P384
#include FIO_INCLUDE_FILE

int verify_tls_certificate_signature(const uint8_t *der_sig,
                                     size_t der_sig_len,
                                     const uint8_t *tbs_hash,
                                     const uint8_t *pubkey) {
  /* der_sig: DER-encoded ECDSA signature from the certificate */
  /* tbs_hash: SHA-384 hash of the TBS (to-be-signed) certificate data */
  /* pubkey: 97-byte uncompressed public key (0x04 || x || y) */

  int result = fio_ecdsa_p384_verify(der_sig, der_sig_len,
                                     tbs_hash,
                                     pubkey, 97);
  if (result == 0) {
    /* Signature is valid */
  } else {
    /* Signature is invalid */
  }
  return result;
}
```

#### Raw Signature Verification

```c
void example_raw_verify(void) {
  /* Raw 48-byte big-endian components */
  uint8_t r[48] = { /* ... r component ... */ };
  uint8_t s[48] = { /* ... s component ... */ };
  uint8_t hash[48] = { /* ... SHA-384 hash of message ... */ };
  uint8_t pub_x[48] = { /* ... public key x-coordinate ... */ };
  uint8_t pub_y[48] = { /* ... public key y-coordinate ... */ };

  int result = fio_ecdsa_p384_verify_raw(r, s, hash, pub_x, pub_y);
  if (result == 0) {
    /* Valid signature */
  } else {
    /* Invalid signature */
  }
}
```

### Implementation Notes

The P-384 implementation uses:

- **6 × 64-bit limb representation** for field elements (little-endian limb order)
- **Jacobian coordinates** for point operations, with mixed affine-Jacobian addition
- **NIST fast reduction** (FIPS 186-4, Section D.2.4) for modular reduction after field multiplication
- **Shamir's trick** for the double scalar multiplication u1·G + u2·Q during verification
- **Fermat's little theorem** for field and scalar inversions (a⁻¹ = a^(p−2) mod p)

The scalar multiplication uses a double-and-add algorithm that is **not** constant-time. This is acceptable for signature verification (which operates only on public data) but would be unsuitable for signing or key generation.

------------------------------------------------------------
