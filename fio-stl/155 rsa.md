## RSA Signature Verification

```c
#define FIO_RSA
#include FIO_INCLUDE_FILE
```

By defining `FIO_RSA`, RSA signature verification functions are made available. This module provides verification-only operations for TLS 1.3 certificate chain validation.

**Supported Features:**
- PKCS#1 v1.5 signatures (sha256WithRSAEncryption, sha384WithRSAEncryption, sha512WithRSAEncryption)
- RSA-PSS signatures (required for TLS 1.3 CertificateVerify)
- Key sizes: 2048, 3072, 4096 bits

**Note**: This module is verification-only. No private key operations (signing, decryption) are supported.

**Note**: This implementation has not been audited. Use at your own risk for security-critical applications.

### Constants

```c
#define FIO_RSA_MAX_BITS  4096  /* Maximum RSA key size in bits */
#define FIO_RSA_MAX_BYTES 512   /* Maximum RSA key size in bytes */
```

### Types

#### `fio_rsa_hash_e`

```c
typedef enum {
  FIO_RSA_HASH_SHA256 = 0, /* SHA-256 (32 bytes) */
  FIO_RSA_HASH_SHA384 = 1, /* SHA-384 (48 bytes) */
  FIO_RSA_HASH_SHA512 = 2, /* SHA-512 (64 bytes) */
} fio_rsa_hash_e;
```

Hash algorithm identifiers for RSA verification.

#### `fio_rsa_pubkey_s`

```c
typedef struct {
  const uint8_t *n; /* Modulus (big-endian) */
  size_t n_len;     /* Modulus length in bytes */
  const uint8_t *e; /* Public exponent (big-endian) */
  size_t e_len;     /* Exponent length in bytes */
} fio_rsa_pubkey_s;
```

RSA public key for signature verification.

The modulus (n) and exponent (e) are stored as big-endian byte arrays, matching the DER encoding used in X.509 certificates.

**Members:**
- `n` - pointer to the RSA modulus in big-endian format
- `n_len` - length of the modulus in bytes (256 for 2048-bit, 384 for 3072-bit, 512 for 4096-bit)
- `e` - pointer to the public exponent in big-endian format (typically 65537 = 0x010001)
- `e_len` - length of the exponent in bytes

### Signature Verification Functions

#### `fio_rsa_verify_pkcs1`

```c
int fio_rsa_verify_pkcs1(const uint8_t *sig,
                         size_t sig_len,
                         const uint8_t *msg_hash,
                         size_t hash_len,
                         fio_rsa_hash_e hash_alg,
                         const fio_rsa_pubkey_s *key);
```

Verifies an RSA PKCS#1 v1.5 signature.

This verifies signatures with DigestInfo encoding as used in:
- sha256WithRSAEncryption (OID 1.2.840.113549.1.1.11)
- sha384WithRSAEncryption (OID 1.2.840.113549.1.1.12)
- sha512WithRSAEncryption (OID 1.2.840.113549.1.1.13)

**Parameters:**
- `sig` - signature bytes (same length as modulus)
- `sig_len` - signature length in bytes
- `msg_hash` - pre-computed hash of the message
- `hash_len` - hash length (32, 48, or 64 bytes)
- `hash_alg` - hash algorithm used (`FIO_RSA_HASH_SHA256`, etc.)
- `key` - RSA public key

**Returns:** 0 on success (valid signature), -1 on failure.

Example:

```c
/* Verify a PKCS#1 v1.5 signature */
fio_rsa_pubkey_s pubkey = {
  .n = modulus_bytes,
  .n_len = 256,  /* 2048-bit key */
  .e = exponent_bytes,
  .e_len = 3     /* 65537 = 0x010001 */
};

/* Hash the message first */
fio_u256 hash = fio_sha256(message, message_len);

/* Verify signature */
if (fio_rsa_verify_pkcs1(signature, 256, hash.u8, 32,
                         FIO_RSA_HASH_SHA256, &pubkey) == 0) {
  printf("Signature is valid\n");
} else {
  printf("Signature verification failed\n");
}
```

#### `fio_rsa_verify_pss`

```c
int fio_rsa_verify_pss(const uint8_t *sig,
                       size_t sig_len,
                       const uint8_t *msg_hash,
                       size_t hash_len,
                       fio_rsa_hash_e hash_alg,
                       const fio_rsa_pubkey_s *key);
```

Verifies an RSA-PSS signature (required for TLS 1.3).

RSA-PSS uses probabilistic padding and is the mandatory signature scheme for TLS 1.3 CertificateVerify messages with RSA keys.

This implementation uses:
- MGF1 with the same hash function
- Salt length = hash length (as required by TLS 1.3)
- Trailer field = 0xBC

**Parameters:**
- `sig` - signature bytes (same length as modulus)
- `sig_len` - signature length in bytes
- `msg_hash` - pre-computed hash of the message
- `hash_len` - hash length (32, 48, or 64 bytes)
- `hash_alg` - hash algorithm used
- `key` - RSA public key

**Returns:** 0 on success (valid signature), -1 on failure.

Example:

```c
/* Verify an RSA-PSS signature (TLS 1.3 CertificateVerify) */
fio_rsa_pubkey_s pubkey = {
  .n = cert->pubkey.rsa.n,
  .n_len = cert->pubkey.rsa.n_len,
  .e = cert->pubkey.rsa.e,
  .e_len = cert->pubkey.rsa.e_len
};

/* The message hash is computed over the TLS 1.3 signed content */
if (fio_rsa_verify_pss(signature, sig_len, content_hash, 32,
                       FIO_RSA_HASH_SHA256, &pubkey) == 0) {
  printf("RSA-PSS signature verified\n");
}
```

### Usage with X.509 Certificates

The RSA module is typically used together with the X.509 module for certificate verification:

```c
#define FIO_X509
#define FIO_RSA
#include "fio-stl/include.h"

int verify_certificate_signature(const fio_x509_cert_s *cert,
                                 const fio_x509_cert_s *issuer) {
  /* Check that issuer has an RSA key */
  if (issuer->key_type != FIO_X509_KEY_RSA)
    return -1;
  
  /* Build RSA public key from issuer certificate */
  fio_rsa_pubkey_s pubkey = {
    .n = issuer->pubkey.rsa.n,
    .n_len = issuer->pubkey.rsa.n_len,
    .e = issuer->pubkey.rsa.e,
    .e_len = issuer->pubkey.rsa.e_len
  };
  
  /* Hash the TBS (To-Be-Signed) certificate data */
  fio_u256 hash = fio_sha256(cert->tbs_data, cert->tbs_len);
  
  /* Verify based on signature algorithm */
  switch (cert->sig_alg) {
  case FIO_X509_SIG_RSA_PKCS1_SHA256:
    return fio_rsa_verify_pkcs1(cert->signature, cert->signature_len,
                                hash.u8, 32, FIO_RSA_HASH_SHA256, &pubkey);
  case FIO_X509_SIG_RSA_PSS_SHA256:
    return fio_rsa_verify_pss(cert->signature, cert->signature_len,
                              hash.u8, 32, FIO_RSA_HASH_SHA256, &pubkey);
  default:
    return -1;
  }
}
```

### Security Considerations

1. **Verification Only**: This module only supports signature verification. Private key operations are not implemented.

2. **Constant-Time Operations**: The implementation uses constant-time comparison for signature verification to prevent timing attacks.

3. **Key Size**: Only 2048-bit and larger keys are supported. Smaller keys are rejected as insecure.

4. **No Auditing**: This implementation has not undergone a formal security audit. For production use in security-critical applications, consider using a well-audited cryptographic library.

------------------------------------------------------------
