## P-256 (secp256r1) Elliptic Curve Cryptography

```c
#define FIO_P256
#include FIO_INCLUDE_FILE
```

By defining `FIO_P256`, the P-256 (secp256r1) elliptic curve cryptography module is defined and made available. This module provides ECDSA signature signing and verification as well as ECDHE (Elliptic Curve Diffie-Hellman Ephemeral) key exchange for the NIST P-256 curve.

P-256 curve parameters (NIST FIPS 186-4):

- **Prime**: p = 2^256 - 2^224 + 2^192 + 2^96 - 1
- **Order**: n = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551
- **Curve equation**: y² = x³ - 3x + b (mod p)

The module supports:

- **ECDSA Verification** - verify DER-encoded or raw (r, s) signatures against a public key
- **ECDSA Signing** - sign a message hash with a secret key, producing a DER-encoded signature
- **ECDHE Key Generation** - generate P-256 keypairs for key exchange
- **ECDHE Shared Secret** - compute shared secrets from a local secret key and a remote public key

**Note**: this implementation has not been audited and is not constant-time. Use at your own risk.

### ECDSA P-256 Verification API

#### `fio_ecdsa_p256_verify`

```c
int fio_ecdsa_p256_verify(const uint8_t *sig,
                          size_t sig_len,
                          const uint8_t *msg_hash,
                          const uint8_t *pubkey,
                          size_t pubkey_len);
```

Verifies an ECDSA P-256 signature encoded in DER format against an uncompressed public key.

Parses the DER-encoded signature (`SEQUENCE { r INTEGER, s INTEGER }`), extracts the (r, s) components, and delegates to the raw verification routine. Validates that the public key is in uncompressed format (65 bytes starting with `0x04`).

**Parameters:**
- `sig` - DER-encoded signature bytes (`SEQUENCE { r INTEGER, s INTEGER }`)
- `sig_len` - length of the signature in bytes
- `msg_hash` - SHA-256 hash of the message (exactly 32 bytes)
- `pubkey` - uncompressed public key (65 bytes: `0x04 || x || y`)
- `pubkey_len` - length of the public key (must be 65)

**Returns:** `0` on success (valid signature), `-1` on failure (invalid signature, malformed input, or NULL parameters).

**Note**: the `msg_hash` must be a SHA-256 digest (32 bytes). The function does **not** hash the message itself.

#### `fio_ecdsa_p256_verify_raw`

```c
int fio_ecdsa_p256_verify_raw(const uint8_t r[32],
                              const uint8_t s[32],
                              const uint8_t msg_hash[32],
                              const uint8_t pubkey_x[32],
                              const uint8_t pubkey_y[32]);
```

Verifies an ECDSA P-256 signature using raw (r, s) components and raw public key coordinates.

Performs the full ECDSA verification algorithm:

1. Validates r, s are in [1, n-1]
2. Verifies the public key point lies on the P-256 curve
3. Computes w = s⁻¹ mod n
4. Computes u1 = e·w mod n and u2 = r·w mod n (where e is the message hash)
5. Computes R = u1·G + u2·Q using Shamir's trick
6. Verifies r == R.x mod n

**Parameters:**
- `r` - the r component of the signature (32 bytes, big-endian)
- `s` - the s component of the signature (32 bytes, big-endian)
- `msg_hash` - SHA-256 hash of the message (32 bytes)
- `pubkey_x` - X coordinate of the public key (32 bytes, big-endian)
- `pubkey_y` - Y coordinate of the public key (32 bytes, big-endian)

**Returns:** `0` on success (valid signature), `-1` on failure.

### ECDSA P-256 Signing API

#### `fio_ecdsa_p256_sign`

```c
int fio_ecdsa_p256_sign(uint8_t *sig,
                        size_t *sig_len,
                        size_t sig_capacity,
                        const uint8_t msg_hash[32],
                        const uint8_t secret_key[32]);
```

Signs a message hash using ECDSA P-256, producing a DER-encoded signature.

Generates a random nonce `k`, computes the signature components (r, s), and DER-encodes the result. Retries up to 100 times if the random nonce produces an invalid signature (extremely unlikely). Sensitive data (secret key copy, nonce, inverse) is securely zeroed after use.

**Parameters:**
- `sig` - output buffer for the DER-encoded signature (maximum 72 bytes)
- `sig_len` - output: actual length of the signature written
- `sig_capacity` - capacity of the `sig` buffer (must be >= 72)
- `msg_hash` - SHA-256 hash of the message to sign (exactly 32 bytes)
- `secret_key` - 32-byte secret key (scalar, big-endian); must be in [1, n-1]

**Returns:** `0` on success, `-1` on failure (invalid parameters, invalid key, or signature generation failed).

**Note**: the function uses `fio_rand_bytes` for nonce generation. The `msg_hash` must be a pre-computed SHA-256 digest. Sensitive key material is securely zeroed after use.

### P-256 ECDHE (Key Exchange) API

#### `fio_p256_keypair`

```c
int fio_p256_keypair(uint8_t secret_key[32], uint8_t public_key[65]);
```

Generates a P-256 keypair for ECDHE key exchange.

Generates a cryptographically random 32-byte scalar as the secret key, validates it is in the range [1, n-1], and computes the corresponding public key point (secret_key · G). The public key is output in uncompressed format (`0x04 || x || y`).

**Parameters:**
- `secret_key` - output: 32-byte secret key (scalar, big-endian)
- `public_key` - output: 65-byte uncompressed public key (`0x04 || x || y`)

**Returns:** `0` on success, `-1` on failure (NULL parameters or random generation failed after 100 attempts).

**Note**: uses `fio_rand_bytes` for random scalar generation.

#### `fio_p256_shared_secret`

```c
int fio_p256_shared_secret(uint8_t shared_secret[32],
                           const uint8_t secret_key[32],
                           const uint8_t *their_public_key,
                           size_t their_public_key_len);
```

Computes a P-256 ECDH shared secret from a local secret key and a remote public key.

Parses the remote public key (supporting both uncompressed 65-byte and compressed 33-byte formats), validates that the point lies on the P-256 curve, and computes the scalar multiplication (secret_key · their_point). The shared secret is the x-coordinate of the resulting point.

**Parameters:**
- `shared_secret` - output: 32-byte shared secret (x-coordinate of the result point)
- `secret_key` - 32-byte local secret key (scalar, big-endian); must be in [1, n-1]
- `their_public_key` - remote party's public key (uncompressed 65 bytes or compressed 33 bytes)
- `their_public_key_len` - length of the remote public key (must be 33 or 65)

**Returns:** `0` on success, `-1` on failure (invalid key, point not on curve, point at infinity, or all-zero result).

**Note**: sensitive data (secret key copy, intermediate points) is securely zeroed after computation. The function rejects all-zero shared secrets as a defense against low-order point attacks. Compressed public keys (`0x02`/`0x03` prefix) are automatically decompressed.

### Examples

#### ECDSA Sign and Verify

```c
#define FIO_P256
#define FIO_SHA2
#include FIO_INCLUDE_FILE

void example_ecdsa(void) {
  /* Generate a keypair */
  uint8_t secret_key[32];
  uint8_t public_key[65];
  fio_p256_keypair(secret_key, public_key);

  /* Hash the message with SHA-256 */
  const char *msg = "Hello, P-256!";
  fio_u256 hash = fio_sha256(msg, strlen(msg));

  /* Sign the hash */
  uint8_t sig[72];
  size_t sig_len;
  int r = fio_ecdsa_p256_sign(sig, &sig_len, sizeof(sig),
                               hash.u8, secret_key);
  if (r != 0) { /* handle error */ }

  /* Verify the signature */
  r = fio_ecdsa_p256_verify(sig, sig_len, hash.u8,
                             public_key, 65);
  if (r == 0) {
    printf("Signature valid!\n");
  } else {
    printf("Signature invalid!\n");
  }
}
```

#### ECDHE Key Exchange

```c
#define FIO_P256
#include FIO_INCLUDE_FILE

void example_ecdhe(void) {
  /* Alice generates her keypair */
  uint8_t alice_sk[32], alice_pk[65];
  fio_p256_keypair(alice_sk, alice_pk);

  /* Bob generates his keypair */
  uint8_t bob_sk[32], bob_pk[65];
  fio_p256_keypair(bob_sk, bob_pk);

  /* Alice computes shared secret using Bob's public key */
  uint8_t alice_shared[32];
  fio_p256_shared_secret(alice_shared, alice_sk, bob_pk, 65);

  /* Bob computes shared secret using Alice's public key */
  uint8_t bob_shared[32];
  fio_p256_shared_secret(bob_shared, bob_sk, alice_pk, 65);

  /* alice_shared and bob_shared are now identical */
}
```

#### Raw Signature Verification

```c
void example_verify_raw(const uint8_t r[32],
                        const uint8_t s[32],
                        const uint8_t hash[32],
                        const uint8_t pub_x[32],
                        const uint8_t pub_y[32]) {
  int result = fio_ecdsa_p256_verify_raw(r, s, hash, pub_x, pub_y);
  if (result == 0) {
    printf("Signature is valid\n");
  } else {
    printf("Signature is invalid\n");
  }
}
```

### ECDSA vs ECDHE Summary

| Operation | Function | Input | Output |
|-----------|----------|-------|--------|
| Sign | `fio_ecdsa_p256_sign` | msg_hash + secret_key | DER signature (max 72 bytes) |
| Verify (DER) | `fio_ecdsa_p256_verify` | DER sig + msg_hash + pubkey | 0 (valid) / -1 (invalid) |
| Verify (raw) | `fio_ecdsa_p256_verify_raw` | r, s + msg_hash + pubkey_x, pubkey_y | 0 (valid) / -1 (invalid) |
| Keypair | `fio_p256_keypair` | (none) | secret_key (32B) + public_key (65B) |
| Shared Secret | `fio_p256_shared_secret` | secret_key + their_pubkey | shared_secret (32B) |

-------------------------------------------------------------------------------
