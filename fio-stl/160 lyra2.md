## Lyra2

```c
#define FIO_LYRA2
#include FIO_INCLUDE_FILE
```

By defining `FIO_LYRA2`, the Lyra2 memory-hard password hashing function is defined and made available.

Lyra2 is a memory-hard password hashing scheme that uses a sponge construction with Blake2b as the underlying permutation. It provides configurable time and memory costs for resistance against GPU/ASIC attacks.

This implementation matches the [reference C implementation](https://github.com/leocalm/Lyra) with `nPARALLEL==1`, `SPONGE==0` (Blake2b), and `RHO==1`.

**Note**: when comparing Lyra2 output hashes, use `fio_ct_is_eq` for constant-time comparison to avoid timing side-channel attacks.

### Lyra2 Functions

#### `fio_lyra2`

```c
fio_u512 fio_lyra2(fio_lyra2_args_s args);
/* Named arguments using macro. */
#define fio_lyra2(...) fio_lyra2((fio_lyra2_args_s){__VA_ARGS__})

typedef struct {
  /** The password to hash. */
  fio_buf_info_s password;
  /** The salt for the hash. */
  fio_buf_info_s salt;
  /** Time cost (number of rounds, minimum 1). */
  uint64_t t_cost;
  /** Memory cost (number of rows in the matrix, minimum 3). */
  uint64_t m_cost;
  /** Desired output length in bytes (default 32 if 0). */
  size_t outlen;
  /** Number of columns (default 256 if 0). */
  size_t n_cols;
} fio_lyra2_args_s;
```

Computes a Lyra2 password hash.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
fio_u512 hash = fio_lyra2(
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 1024);
/* hash.u8[0..31] contains the 32-byte password hash */
```

**Named Arguments:**

| Argument | Type | Description |
|----------|------|-------------|
| `password` | `fio_buf_info_s` | The password to hash |
| `salt` | `fio_buf_info_s` | Salt / nonce (should be random) |
| `t_cost` | `uint64_t` | Time cost / number of rounds (minimum 1) |
| `m_cost` | `uint64_t` | Memory cost / number of matrix rows (minimum 3) |
| `outlen` | `size_t` | Output length in bytes (default 32 if 0) |
| `n_cols` | `size_t` | Number of matrix columns (default 256 if 0) |

**Returns:** a `fio_u512` containing the password hash. Only the first `outlen` bytes are valid (default 32). For output lengths greater than 64 bytes, use `fio_lyra2_hash` instead.

#### `fio_lyra2_hash`

```c
int fio_lyra2_hash(void *out, fio_lyra2_args_s args);
/* Named arguments using macro. */
#define fio_lyra2_hash(out, ...) fio_lyra2_hash(out, (fio_lyra2_args_s){__VA_ARGS__})
```

Computes a Lyra2 password hash into a caller-provided buffer.

Supports arbitrary output lengths. Use this instead of `fio_lyra2` when the desired output length exceeds 64 bytes.

The function is shadowed by a macro, allowing it to accept named arguments:

```c
uint8_t hash[128];
int r = fio_lyra2_hash(hash,
    .password = FIO_BUF_INFO1("my-password"),
    .salt = FIO_BUF_INFO1("random-salt"),
    .t_cost = 3,
    .m_cost = 1024,
    .outlen = 128);
```

**Parameters:**
- `out` - destination buffer (must have capacity for at least `outlen` bytes)
- Named arguments are the same as `fio_lyra2` (see table above)

**Returns:** 0 on success, -1 on error.

### Lyra2 Example

```c
#define FIO_LYRA2
#include FIO_INCLUDE_FILE

void example_lyra2(void) {
  fio_u512 hash = fio_lyra2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 1024);

  /* Verify: recompute and compare in constant time */
  fio_u512 verify = fio_lyra2(
      .password = FIO_BUF_INFO1("user-password"),
      .salt = FIO_BUF_INFO1("unique-random-salt"),
      .t_cost = 3,
      .m_cost = 1024);

  if (fio_ct_is_eq(hash.u8, verify.u8, 32))
    printf("Password matches!\n");
}
```

-------------------------------------------------------------------------------
