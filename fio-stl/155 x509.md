## X.509 Certificate Parser

```c
#define FIO_X509
#include FIO_INCLUDE_FILE
```

By defining `FIO_X509`, an X.509v3 certificate parser is made available for TLS 1.3 certificate verification. This module provides parsing and validation capabilities for DER-encoded certificates.

**Supported Features:**
- RSA, ECDSA (P-256, P-384), and Ed25519 public keys
- Signature verification using issuer certificates
- Validity period checking
- Hostname matching (CN and SAN with wildcards)
- Basic constraints and key usage extensions
- Certificate chain validation
- Trust store management

**Note**: This is a minimal parser for TLS 1.3. Not all X.509 features are supported. The implementation is non-allocating (pointers into DER data).

### Types

#### `fio_x509_key_type_e`

```c
typedef enum {
  FIO_X509_KEY_UNKNOWN = 0,
  FIO_X509_KEY_RSA = 1,        /* RSA (any key size) */
  FIO_X509_KEY_ECDSA_P256 = 2, /* ECDSA with P-256/secp256r1 */
  FIO_X509_KEY_ECDSA_P384 = 3, /* ECDSA with P-384/secp384r1 */
  FIO_X509_KEY_ED25519 = 4,    /* Ed25519 (EdDSA) */
} fio_x509_key_type_e;
```

Public key algorithm types supported in certificates.

#### `fio_x509_sig_alg_e`

```c
typedef enum {
  FIO_X509_SIG_UNKNOWN = 0,
  FIO_X509_SIG_RSA_PKCS1_SHA256 = 1, /* sha256WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA384 = 2, /* sha384WithRSAEncryption */
  FIO_X509_SIG_RSA_PKCS1_SHA512 = 3, /* sha512WithRSAEncryption */
  FIO_X509_SIG_RSA_PSS_SHA256 = 4,   /* RSA-PSS with SHA-256 */
  FIO_X509_SIG_RSA_PSS_SHA384 = 5,   /* RSA-PSS with SHA-384 */
  FIO_X509_SIG_RSA_PSS_SHA512 = 6,   /* RSA-PSS with SHA-512 */
  FIO_X509_SIG_ECDSA_SHA256 = 7,     /* ecdsa-with-SHA256 */
  FIO_X509_SIG_ECDSA_SHA384 = 8,     /* ecdsa-with-SHA384 */
  FIO_X509_SIG_ED25519 = 9,          /* Ed25519 */
} fio_x509_sig_alg_e;
```

Signature algorithm types used in certificate signatures.

#### `fio_x509_key_usage_e`

```c
typedef enum {
  FIO_X509_KU_DIGITAL_SIGNATURE = 0x0001,
  FIO_X509_KU_NON_REPUDIATION = 0x0002,
  FIO_X509_KU_KEY_ENCIPHERMENT = 0x0004,
  FIO_X509_KU_DATA_ENCIPHERMENT = 0x0008,
  FIO_X509_KU_KEY_AGREEMENT = 0x0010,
  FIO_X509_KU_KEY_CERT_SIGN = 0x0020,
  FIO_X509_KU_CRL_SIGN = 0x0040,
  FIO_X509_KU_ENCIPHER_ONLY = 0x0080,
  FIO_X509_KU_DECIPHER_ONLY = 0x0100,
} fio_x509_key_usage_e;
```

Key Usage bit flags (RFC 5280 Section 4.2.1.3).

#### `fio_x509_error_e`

```c
typedef enum {
  FIO_X509_OK = 0,                     /* Validation successful */
  FIO_X509_ERR_PARSE = -1,             /* Failed to parse certificate */
  FIO_X509_ERR_EXPIRED = -2,           /* Certificate expired */
  FIO_X509_ERR_NOT_YET_VALID = -3,     /* Certificate not yet valid */
  FIO_X509_ERR_SIGNATURE = -4,         /* Signature verification failed */
  FIO_X509_ERR_ISSUER_MISMATCH = -5,   /* Issuer DN doesn't match subject DN */
  FIO_X509_ERR_NOT_CA = -6,            /* Issuer is not a CA certificate */
  FIO_X509_ERR_NO_TRUST_ANCHOR = -7,   /* Certificate not in trust store */
  FIO_X509_ERR_HOSTNAME_MISMATCH = -8, /* Hostname doesn't match cert */
  FIO_X509_ERR_EMPTY_CHAIN = -9,       /* Empty certificate chain */
  FIO_X509_ERR_CHAIN_TOO_LONG = -10,   /* Chain exceeds maximum depth */
} fio_x509_error_e;
```

Certificate chain validation error codes.

#### `fio_x509_trust_store_s`

```c
typedef struct {
  const uint8_t **roots;   /* Array of root CA certificate DER data */
  const size_t *root_lens; /* Array of root CA certificate lengths */
  size_t root_count;       /* Number of root CAs */
} fio_x509_trust_store_s;
```

Trust store for root CA certificates.

**Members:**
- `roots` - array of pointers to DER-encoded root CA certificates
- `root_lens` - array of lengths for each root certificate
- `root_count` - number of root CAs in the trust store

#### `fio_x509_cert_s`

```c
typedef struct {
  /* Certificate version (0=v1, 1=v2, 2=v3) */
  int version;

  /* Validity period (Unix timestamps) */
  int64_t not_before;
  int64_t not_after;

  /* Subject Distinguished Name (raw DER for comparison) */
  const uint8_t *subject_der;
  size_t subject_der_len;

  /* Issuer Distinguished Name (raw DER for comparison) */
  const uint8_t *issuer_der;
  size_t issuer_der_len;

  /* Subject Common Name (if present, pointer into DER data) */
  const char *subject_cn;
  size_t subject_cn_len;

  /* Public Key Type */
  fio_x509_key_type_e key_type;

  /* Public Key Data (union based on key_type) */
  union {
    struct {
      const uint8_t *n;  /* RSA modulus (big-endian) */
      size_t n_len;
      const uint8_t *e;  /* RSA exponent (big-endian) */
      size_t e_len;
    } rsa;
    struct {
      const uint8_t *point;  /* Uncompressed EC point (04 || x || y) */
      size_t point_len;
    } ecdsa;
    struct {
      const uint8_t *key;  /* 32-byte Ed25519 public key */
    } ed25519;
  } pubkey;

  /* Signature Algorithm */
  fio_x509_sig_alg_e sig_alg;

  /* Signature value (pointer into DER data) */
  const uint8_t *signature;
  size_t signature_len;

  /* TBS Certificate (for signature verification) */
  const uint8_t *tbs_data;
  size_t tbs_len;

  /* Basic Constraints: is CA */
  int is_ca;

  /* Key Usage extension present */
  int has_key_usage;
  /* Key Usage bits */
  uint16_t key_usage;

  /* Subject Alternative Name: first DNS name (if present) */
  const char *san_dns;
  size_t san_dns_len;
} fio_x509_cert_s;
```

Parsed X.509 certificate structure.

**Note**: All pointers reference the original DER data, which must remain valid while the certificate structure is in use.

### Certificate Parsing Functions

#### `fio_x509_parse`

```c
int fio_x509_parse(fio_x509_cert_s *cert,
                   const uint8_t *der_data,
                   size_t der_len);
```

Parses a DER-encoded X.509 certificate.

The cert structure will contain pointers into the original DER data, so the DER data must remain valid while the cert is in use.

**Parameters:**
- `cert` - output certificate structure (will be zeroed first)
- `der_data` - pointer to DER-encoded certificate
- `der_len` - length of DER data in bytes

**Returns:** 0 on success, -1 on error.

Example:

```c
fio_x509_cert_s cert;
if (fio_x509_parse(&cert, der_data, der_len) == 0) {
  printf("Subject CN: %.*s\n", (int)cert.subject_cn_len, cert.subject_cn);
  printf("Key type: %d\n", cert.key_type);
  printf("Is CA: %s\n", cert.is_ca ? "yes" : "no");
}
```

#### `fio_x509_verify_signature`

```c
int fio_x509_verify_signature(const fio_x509_cert_s *cert,
                              const fio_x509_cert_s *issuer);
```

Verifies certificate signature using issuer's public key.

This verifies that the certificate was signed by the issuer.

**Parameters:**
- `cert` - certificate to verify
- `issuer` - certificate of the issuer (contains the public key)

**Returns:** 0 if valid, -1 if invalid or error.

**Note**: Requires `FIO_RSA` module for RSA signatures and `FIO_ED25519` for Ed25519 signatures.

#### `fio_x509_check_validity`

```c
int fio_x509_check_validity(const fio_x509_cert_s *cert, int64_t current_time);
```

Checks if certificate is currently valid (not expired, not yet valid).

**Parameters:**
- `cert` - certificate to check
- `current_time` - current Unix timestamp (seconds since epoch)

**Returns:** 0 if valid, -1 if expired or not yet valid.

#### `fio_x509_match_hostname`

```c
int fio_x509_match_hostname(const fio_x509_cert_s *cert,
                            const char *hostname,
                            size_t hostname_len);
```

Checks if hostname matches certificate (CN or SAN).

Supports wildcard matching (*.example.com). Per RFC 6125, wildcards only match one label.

**Parameters:**
- `cert` - certificate to check
- `hostname` - hostname to match
- `hostname_len` - length of hostname

**Returns:** 0 if match, -1 if no match.

Example:

```c
if (fio_x509_match_hostname(&cert, "www.example.com", 15) == 0) {
  printf("Hostname matches certificate\n");
}
```

#### `fio_x509_dn_equals`

```c
int fio_x509_dn_equals(const uint8_t *dn1, size_t dn1_len,
                       const uint8_t *dn2, size_t dn2_len);
```

Compares two Distinguished Names for equality.

Used for checking if issuer DN matches subject DN.

**Parameters:**
- `dn1` - first DN (DER-encoded)
- `dn1_len` - length of first DN
- `dn2` - second DN (DER-encoded)
- `dn2_len` - length of second DN

**Returns:** 0 if equal, non-zero if different.

### Certificate Chain Validation

#### `fio_x509_verify_chain`

```c
int fio_x509_verify_chain(const uint8_t **certs,
                          const size_t *cert_lens,
                          size_t cert_count,
                          const char *hostname,
                          int64_t current_time,
                          fio_x509_trust_store_s *trust_store);
```

Validates a certificate chain for TLS 1.3.

The chain should be ordered from end-entity to closest-to-root:
- `certs[0]` = server's certificate (end-entity)
- `certs[1]` = intermediate CA (signed certs[0])
- `certs[n-1]` = closest to root (may be root or intermediate)

**Validation performs:**
1. Parse all certificates
2. Check validity period for all certificates
3. Verify hostname matches end-entity certificate (if hostname provided)
4. Verify each certificate's signature using the next certificate's key
5. Verify issuer DNs match subject DNs in the chain
6. Verify intermediate/root certificates have CA:TRUE
7. Verify the chain terminates at a trusted root (if trust store provided)

**Parameters:**
- `certs` - array of DER-encoded certificates
- `cert_lens` - array of certificate lengths
- `cert_count` - number of certificates in chain
- `hostname` - expected hostname for end-entity (NULL to skip check)
- `current_time` - current Unix timestamp for validity checking
- `trust_store` - root CA certificates (NULL to skip trust check)

**Returns:** `FIO_X509_OK` (0) on success, or error code on failure.

Example:

```c
/* Set up trust store with root CAs */
const uint8_t *roots[] = { root_ca_der };
const size_t root_lens[] = { root_ca_len };
fio_x509_trust_store_s trust_store = {
  .roots = roots,
  .root_lens = root_lens,
  .root_count = 1
};

/* Verify certificate chain */
int result = fio_x509_verify_chain(
  cert_chain, cert_lens, cert_count,
  "www.example.com",
  time(NULL),
  &trust_store
);

if (result == FIO_X509_OK) {
  printf("Certificate chain is valid\n");
} else {
  printf("Validation failed: %s\n", fio_x509_error_str(result));
}
```

#### `fio_x509_is_trusted`

```c
int fio_x509_is_trusted(const fio_x509_cert_s *cert,
                        fio_x509_trust_store_s *trust_store);
```

Checks if a certificate is in the trust store.

Comparison is done by matching subject DN.

**Parameters:**
- `cert` - certificate to check
- `trust_store` - trust store to search

**Returns:** 0 if trusted, -1 if not found.

#### `fio_x509_error_str`

```c
const char *fio_x509_error_str(int error);
```

Gets human-readable error string for X.509 validation error code.

**Parameters:**
- `error` - error code from `fio_x509_verify_chain`

**Returns:** static string describing the error.

### TLS Certificate Message Parsing

#### `fio_tls_cert_entry_s`

```c
typedef struct {
  const uint8_t *cert; /* DER-encoded certificate data */
  size_t cert_len;     /* Certificate length */
} fio_tls_cert_entry_s;
```

TLS certificate entry (parsed from Certificate message).

#### `fio_tls_parse_certificate_message`

```c
int fio_tls_parse_certificate_message(fio_tls_cert_entry_s *entries,
                                      size_t max_entries,
                                      const uint8_t *data,
                                      size_t data_len);
```

Parses TLS 1.3 Certificate message into individual certificates.

**Parameters:**
- `entries` - output array for certificate entries
- `max_entries` - maximum entries to parse
- `data` - raw Certificate message data (after handshake header)
- `data_len` - length of Certificate message data

**Returns:** number of certificates parsed, or -1 on error.

### Complete Example

```c
#define FIO_X509
#define FIO_RSA
#define FIO_ASN1
#include "fio-stl/include.h"

int verify_server_certificate(const uint8_t **chain, const size_t *lens,
                              size_t count, const char *hostname) {
  /* Set up trust store (in practice, load from system or file) */
  fio_x509_trust_store_s trust_store = {
    .roots = trusted_roots,
    .root_lens = trusted_root_lens,
    .root_count = trusted_root_count
  };
  
  /* Get current time */
  int64_t now = (int64_t)time(NULL);
  
  /* Verify the chain */
  int result = fio_x509_verify_chain(chain, lens, count,
                                     hostname, now, &trust_store);
  
  if (result != FIO_X509_OK) {
    fprintf(stderr, "Certificate verification failed: %s\n",
            fio_x509_error_str(result));
    return -1;
  }
  
  printf("Certificate chain verified successfully\n");
  
  /* Optionally, extract information from the end-entity certificate */
  fio_x509_cert_s cert;
  if (fio_x509_parse(&cert, chain[0], lens[0]) == 0) {
    printf("Server: %.*s\n", (int)cert.subject_cn_len, cert.subject_cn);
    printf("Valid until: %lld\n", (long long)cert.not_after);
  }
  
  return 0;
}
```

------------------------------------------------------------
