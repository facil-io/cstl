## TLS 1.3 Client

```c
#define FIO_TLS13
#include FIO_INCLUDE_FILE
```

By defining `FIO_TLS13`, a TLS 1.3 client implementation is made available. This module provides the complete TLS 1.3 handshake protocol, record layer encryption/decryption, and key schedule derivation functions.

**Requirements:**
- `FIO_HKDF` (which requires `FIO_SHA2`) for key derivation
- `FIO_AES` for AES-GCM cipher suites
- `FIO_CHACHA` for ChaCha20-Poly1305 cipher suite
- `FIO_X25519` for key exchange
- `FIO_X509` and `FIO_RSA` for certificate verification (optional)

**Supported Features:**
- Cipher suites: TLS_AES_128_GCM_SHA256, TLS_AES_256_GCM_SHA384, TLS_CHACHA20_POLY1305_SHA256
- Key exchange: X25519
- Signature algorithms: RSA-PSS, RSA-PKCS1, Ed25519, ECDSA (P-256, P-384)
- Server Name Indication (SNI)
- Certificate chain verification (when FIO_X509 is included)

**Note**: This implementation has not been audited. Use at your own risk for security-critical applications.

------------------------------------------------------------

### Constants

```c
/* Hash lengths */
#define FIO_TLS13_SHA256_HASH_LEN 32
#define FIO_TLS13_SHA384_HASH_LEN 48
#define FIO_TLS13_MAX_HASH_LEN    48

/* Key lengths */
#define FIO_TLS13_AES128_KEY_LEN 16
#define FIO_TLS13_AES256_KEY_LEN 32
#define FIO_TLS13_CHACHA_KEY_LEN 32
#define FIO_TLS13_IV_LEN         12

/* Record layer */
#define FIO_TLS13_RECORD_HEADER_LEN  5
#define FIO_TLS13_MAX_PLAINTEXT_LEN  16384
#define FIO_TLS13_MAX_CIPHERTEXT_LEN (16384 + 256)
#define FIO_TLS13_TAG_LEN            16
```

------------------------------------------------------------

### Types

#### `fio_tls13_content_type_e`

```c
typedef enum {
  FIO_TLS13_CONTENT_INVALID = 0,
  FIO_TLS13_CONTENT_CHANGE_CIPHER_SPEC = 20, /* Legacy, ignored in TLS 1.3 */
  FIO_TLS13_CONTENT_ALERT = 21,
  FIO_TLS13_CONTENT_HANDSHAKE = 22,
  FIO_TLS13_CONTENT_APPLICATION_DATA = 23,
} fio_tls13_content_type_e;
```

TLS 1.3 content types (RFC 8446 Section 5.1).

#### `fio_tls13_handshake_type_e`

```c
typedef enum {
  FIO_TLS13_HS_CLIENT_HELLO = 1,
  FIO_TLS13_HS_SERVER_HELLO = 2,
  FIO_TLS13_HS_NEW_SESSION_TICKET = 4,
  FIO_TLS13_HS_END_OF_EARLY_DATA = 5,
  FIO_TLS13_HS_ENCRYPTED_EXTENSIONS = 8,
  FIO_TLS13_HS_CERTIFICATE = 11,
  FIO_TLS13_HS_CERTIFICATE_REQUEST = 13,
  FIO_TLS13_HS_CERTIFICATE_VERIFY = 15,
  FIO_TLS13_HS_FINISHED = 20,
  FIO_TLS13_HS_KEY_UPDATE = 24,
} fio_tls13_handshake_type_e;
```

TLS 1.3 handshake message types (RFC 8446 Section 4).

#### `fio_tls13_cipher_suite_e`

```c
typedef enum {
  FIO_TLS13_CIPHER_SUITE_AES_128_GCM_SHA256 = 0x1301,
  FIO_TLS13_CIPHER_SUITE_AES_256_GCM_SHA384 = 0x1302,
  FIO_TLS13_CIPHER_SUITE_CHACHA20_POLY1305_SHA256 = 0x1303,
} fio_tls13_cipher_suite_e;
```

TLS 1.3 cipher suites (RFC 8446 Section B.4).

#### `fio_tls13_cipher_type_e`

```c
typedef enum {
  FIO_TLS13_CIPHER_AES_128_GCM = 0,
  FIO_TLS13_CIPHER_AES_256_GCM = 1,
  FIO_TLS13_CIPHER_CHACHA20_POLY1305 = 2,
} fio_tls13_cipher_type_e;
```

Supported AEAD cipher types for TLS 1.3.

#### `fio_tls13_record_keys_s`

```c
typedef struct {
  uint8_t key[32];          /* Write key (16 or 32 bytes depending on cipher) */
  uint8_t iv[12];           /* Write IV (always 12 bytes) */
  uint64_t sequence_number; /* Per-record sequence number (starts at 0) */
  uint8_t key_len;          /* 16 for AES-128, 32 for AES-256/ChaCha20 */
  uint8_t cipher_type;      /* fio_tls13_cipher_type_e */
} fio_tls13_record_keys_s;
```

Record encryption context (per-direction keys).

#### `fio_tls13_client_state_e`

```c
typedef enum {
  FIO_TLS13_STATE_START = 0,     /* Initial state */
  FIO_TLS13_STATE_WAIT_SH,       /* Sent ClientHello, waiting for ServerHello */
  FIO_TLS13_STATE_WAIT_EE,       /* Received ServerHello, waiting for EE */
  FIO_TLS13_STATE_WAIT_CERT_CR,  /* Waiting for Certificate or CertRequest */
  FIO_TLS13_STATE_WAIT_CERT,     /* Waiting for Certificate */
  FIO_TLS13_STATE_WAIT_CV,       /* Waiting for CertificateVerify */
  FIO_TLS13_STATE_WAIT_FINISHED, /* Waiting for server Finished */
  FIO_TLS13_STATE_CONNECTED,     /* Handshake complete */
  FIO_TLS13_STATE_ERROR,         /* Error state */
} fio_tls13_client_state_e;
```

TLS 1.3 client handshake states.

#### `fio_tls13_client_s`

```c
typedef struct {
  /* State */
  fio_tls13_client_state_e state;

  /* Negotiated parameters */
  uint16_t cipher_suite;
  int use_sha384;

  /* Key material */
  uint8_t client_random[32];
  uint8_t x25519_private_key[32];
  uint8_t x25519_public_key[32];
  uint8_t shared_secret[32];

  /* Traffic keys */
  fio_tls13_record_keys_s client_handshake_keys;
  fio_tls13_record_keys_s server_handshake_keys;
  fio_tls13_record_keys_s client_app_keys;
  fio_tls13_record_keys_s server_app_keys;

  /* Server certificate info */
  const uint8_t *server_cert;
  size_t server_cert_len;

  /* Error info */
  uint8_t alert_level;
  uint8_t alert_description;

  /* Configuration */
  const char *server_name;
  void *trust_store;
  uint8_t skip_cert_verify;
  /* ... additional internal fields ... */
} fio_tls13_client_s;
```

TLS 1.3 client context containing all state for a connection.

------------------------------------------------------------

### Key Schedule Functions (RFC 8446 Section 7)

#### `fio_tls13_hkdf_expand_label`

```c
void fio_tls13_hkdf_expand_label(void *restrict out,
                                 size_t out_len,
                                 const void *restrict secret,
                                 size_t secret_len,
                                 const char *label,
                                 size_t label_len,
                                 const void *restrict context,
                                 size_t context_len,
                                 int use_sha384);
```

TLS 1.3 HKDF-Expand-Label function.

Derives keying material using the TLS 1.3 specific label format:
```
HKDF-Expand-Label(Secret, Label, Context, Length) =
    HKDF-Expand(Secret, HkdfLabel, Length)
```

**Parameters:**
- `out` - output buffer for derived key material
- `out_len` - desired output length (max 255)
- `secret` - the secret to expand (PRK from HKDF-Extract)
- `secret_len` - secret length (32 for SHA-256, 48 for SHA-384)
- `label` - the label string (without "tls13 " prefix)
- `label_len` - label length (max 249)
- `context` - optional context (transcript hash or empty)
- `context_len` - context length (max 255)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_secret`

```c
void fio_tls13_derive_secret(void *restrict out,
                             const void *restrict secret,
                             size_t secret_len,
                             const char *label,
                             size_t label_len,
                             const void *restrict transcript_hash,
                             size_t hash_len,
                             int use_sha384);
```

TLS 1.3 Derive-Secret function.

```
Derive-Secret(Secret, Label, Messages) =
    HKDF-Expand-Label(Secret, Label, Transcript-Hash(Messages), Hash.length)
```

**Parameters:**
- `out` - output buffer (32 bytes for SHA-256, 48 for SHA-384)
- `secret` - the base secret
- `secret_len` - secret length
- `label` - the label string (e.g., "c hs traffic")
- `label_len` - label length
- `transcript_hash` - hash of handshake messages (or NULL for empty hash)
- `hash_len` - hash length (32 or 48)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_early_secret`

```c
void fio_tls13_derive_early_secret(void *restrict early_secret,
                                   const void *restrict psk,
                                   size_t psk_len,
                                   int use_sha384);
```

Derives the Early Secret from PSK.

```
Early Secret = HKDF-Extract(salt=0, IKM=PSK)
```

**Parameters:**
- `early_secret` - output buffer (32 or 48 bytes)
- `psk` - pre-shared key (or NULL for no PSK)
- `psk_len` - PSK length (0 if no PSK)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_handshake_secret`

```c
void fio_tls13_derive_handshake_secret(void *restrict handshake_secret,
                                       const void *restrict early_secret,
                                       const void *restrict ecdhe_secret,
                                       size_t ecdhe_len,
                                       int use_sha384);
```

Derives the Handshake Secret from ECDHE shared secret.

**Parameters:**
- `handshake_secret` - output buffer (32 or 48 bytes)
- `early_secret` - the early secret
- `ecdhe_secret` - the ECDHE shared secret (e.g., from X25519)
- `ecdhe_len` - ECDHE secret length (32 for X25519)
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_master_secret`

```c
void fio_tls13_derive_master_secret(void *restrict master_secret,
                                    const void *restrict handshake_secret,
                                    int use_sha384);
```

Derives the Master Secret.

**Parameters:**
- `master_secret` - output buffer (32 or 48 bytes)
- `handshake_secret` - the handshake secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_traffic_keys`

```c
void fio_tls13_derive_traffic_keys(void *restrict key,
                                   size_t key_len,
                                   void *restrict iv,
                                   const void *restrict traffic_secret,
                                   int use_sha384);
```

Derives traffic keys and IV from a traffic secret.

**Parameters:**
- `key` - output buffer for write key
- `key_len` - key length (16 for AES-128, 32 for AES-256/ChaCha20)
- `iv` - output buffer for write IV (12 bytes)
- `traffic_secret` - the traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_derive_finished_key`

```c
void fio_tls13_derive_finished_key(void *restrict finished_key,
                                   const void *restrict traffic_secret,
                                   int use_sha384);
```

Derives the Finished key from a traffic secret.

**Parameters:**
- `finished_key` - output buffer (32 or 48 bytes)
- `traffic_secret` - the handshake traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_compute_finished`

```c
void fio_tls13_compute_finished(void *restrict verify_data,
                                const void *restrict finished_key,
                                const void *restrict transcript_hash,
                                int use_sha384);
```

Computes the Finished verify_data.

```
verify_data = HMAC(finished_key, Transcript-Hash(Handshake Context))
```

**Parameters:**
- `verify_data` - output buffer (32 or 48 bytes)
- `finished_key` - the finished key
- `transcript_hash` - hash of handshake messages up to this point
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

#### `fio_tls13_update_traffic_secret`

```c
void fio_tls13_update_traffic_secret(void *restrict new_secret,
                                     const void *restrict current_secret,
                                     int use_sha384);
```

Updates application traffic secret for key update.

**Parameters:**
- `new_secret` - output buffer (32 or 48 bytes)
- `current_secret` - current application traffic secret
- `use_sha384` - if non-zero, use SHA-384; otherwise SHA-256

------------------------------------------------------------

### Record Layer Functions (RFC 8446 Section 5)

#### `fio_tls13_build_nonce`

```c
void fio_tls13_build_nonce(uint8_t nonce[12],
                           const uint8_t iv[12],
                           uint64_t seq);
```

Builds per-record nonce by XORing sequence number with IV.

**Parameters:**
- `nonce` - output buffer (must be 12 bytes)
- `iv` - static IV from key derivation (12 bytes)
- `seq` - 64-bit sequence number

#### `fio_tls13_record_parse_header`

```c
const uint8_t *fio_tls13_record_parse_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_content_type_e *content_type,
    size_t *payload_len);
```

Parses a TLS record header.

**Parameters:**
- `data` - input buffer containing record data
- `data_len` - length of input buffer
- `content_type` - output: content type from header
- `payload_len` - output: payload length from header

**Returns:** pointer to payload data, or NULL if incomplete/invalid.

#### `fio_tls13_record_encrypt`

```c
int fio_tls13_record_encrypt(uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *plaintext,
                             size_t plaintext_len,
                             fio_tls13_content_type_e content_type,
                             fio_tls13_record_keys_s *keys);
```

Encrypts a TLS 1.3 record.

Output format: 5-byte header + encrypted(plaintext + content_type) + tag

**Parameters:**
- `out` - output buffer for encrypted record
- `out_capacity` - capacity of output buffer
- `plaintext` - plaintext data to encrypt
- `plaintext_len` - length of plaintext
- `content_type` - content type (appended to plaintext before encryption)
- `keys` - encryption keys (sequence number will be incremented)

**Returns:** total output length (header + ciphertext + tag), or -1 on error.

#### `fio_tls13_record_decrypt`

```c
int fio_tls13_record_decrypt(uint8_t *out,
                             size_t out_capacity,
                             fio_tls13_content_type_e *content_type,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len,
                             fio_tls13_record_keys_s *keys);
```

Decrypts a TLS 1.3 record.

**Parameters:**
- `out` - output buffer for decrypted plaintext
- `out_capacity` - capacity of output buffer
- `content_type` - output: actual content type from inner plaintext
- `ciphertext` - input ciphertext (includes 5-byte header)
- `ciphertext_len` - total length including header
- `keys` - decryption keys (sequence number will be incremented)

**Returns:** plaintext length (excluding padding and content type), or -1 on error.

#### `fio_tls13_record_keys_init`

```c
void fio_tls13_record_keys_init(fio_tls13_record_keys_s *keys,
                                const uint8_t *key,
                                uint8_t key_len,
                                const uint8_t iv[12],
                                fio_tls13_cipher_type_e cipher_type);
```

Initializes record keys structure.

**Parameters:**
- `keys` - keys structure to initialize
- `key` - key material (16 or 32 bytes)
- `key_len` - key length
- `iv` - IV material (12 bytes)
- `cipher_type` - cipher type

#### `fio_tls13_record_keys_clear`

```c
void fio_tls13_record_keys_clear(fio_tls13_record_keys_s *keys);
```

Clears sensitive key material from memory.

------------------------------------------------------------

### Handshake Message Functions

#### `fio_tls13_parse_handshake_header`

```c
const uint8_t *fio_tls13_parse_handshake_header(
    const uint8_t *data,
    size_t data_len,
    fio_tls13_handshake_type_e *msg_type,
    size_t *body_len);
```

Parses handshake header, returns message type and body pointer.

**Returns:** pointer to message body, or NULL on error.

#### `fio_tls13_write_handshake_header`

```c
void fio_tls13_write_handshake_header(uint8_t *out,
                                      fio_tls13_handshake_type_e msg_type,
                                      size_t body_len);
```

Writes handshake header (4 bytes): HandshakeType (1 byte) + uint24 length (3 bytes).

#### `fio_tls13_build_client_hello`

```c
int fio_tls13_build_client_hello(uint8_t *out,
                                 size_t out_capacity,
                                 const uint8_t random[32],
                                 const char *server_name,
                                 const uint8_t *x25519_pubkey,
                                 const uint16_t *cipher_suites,
                                 size_t cipher_suite_count);
```

Builds a ClientHello message.

**Parameters:**
- `out` - output buffer
- `out_capacity` - size of output buffer
- `random` - 32-byte client random
- `server_name` - SNI hostname (NULL if not used)
- `x25519_pubkey` - 32-byte X25519 public key
- `cipher_suites` - array of cipher suites to offer
- `cipher_suite_count` - number of cipher suites

**Returns:** message length on success, -1 on error.

#### `fio_tls13_parse_server_hello`

```c
int fio_tls13_parse_server_hello(fio_tls13_server_hello_s *out,
                                 const uint8_t *data,
                                 size_t data_len);
```

Parses ServerHello message.

**Returns:** 0 on success, -1 on error.

#### `fio_tls13_build_finished`

```c
int fio_tls13_build_finished(uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *verify_data,
                             size_t verify_data_len);
```

Builds Finished message.

**Returns:** message length on success, -1 on error.

#### `fio_tls13_parse_finished`

```c
int fio_tls13_parse_finished(const uint8_t *data,
                             size_t data_len,
                             const uint8_t *expected_verify_data,
                             size_t verify_data_len);
```

Parses and verifies Finished message.

**Returns:** 0 on success (MAC matches), -1 on error.

------------------------------------------------------------

### Client API

#### `fio_tls13_client_init`

```c
void fio_tls13_client_init(fio_tls13_client_s *client, const char *server_name);
```

Initializes client context.

**Parameters:**
- `client` - client context to initialize
- `server_name` - SNI hostname (can be NULL)

#### `fio_tls13_client_destroy`

```c
void fio_tls13_client_destroy(fio_tls13_client_s *client);
```

Cleans up client context (zeroes secrets).

#### `fio_tls13_client_set_trust_store`

```c
void fio_tls13_client_set_trust_store(fio_tls13_client_s *client,
                                      void *trust_store);
```

Sets trust store for certificate chain verification.

When set, the client will verify the server's certificate chain against the provided trust store. If NULL (default), chain verification is skipped.

**Note**: Requires `FIO_X509` module. The trust_store pointer must point to a valid `fio_x509_trust_store_s` structure.

#### `fio_tls13_client_skip_verification`

```c
void fio_tls13_client_skip_verification(fio_tls13_client_s *client, int skip);
```

Skips all certificate verification (insecure).

When enabled, the client will NOT verify CertificateVerify signature, certificate chain, or hostname matching.

**Warning**: This is insecure and should only be used for testing.

#### `fio_tls13_client_start`

```c
int fio_tls13_client_start(fio_tls13_client_s *client,
                           uint8_t *out,
                           size_t out_capacity);
```

Generates ClientHello message and starts handshake.

**Parameters:**
- `client` - client context
- `out` - output buffer for ClientHello record
- `out_capacity` - capacity of output buffer

**Returns:** message length on success, -1 on error.

#### `fio_tls13_client_process`

```c
int fio_tls13_client_process(fio_tls13_client_s *client,
                             const uint8_t *in,
                             size_t in_len,
                             uint8_t *out,
                             size_t out_capacity,
                             size_t *out_len);
```

Processes incoming TLS record(s).

May generate response data in out buffer.

**Parameters:**
- `client` - client context
- `in` - input buffer containing TLS record(s)
- `in_len` - length of input data
- `out` - output buffer for response
- `out_capacity` - capacity of output buffer
- `out_len` - output: response length (0 if no response needed)

**Returns:** number of bytes consumed, or -1 on error.

#### `fio_tls13_client_encrypt`

```c
int fio_tls13_client_encrypt(fio_tls13_client_s *client,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *plaintext,
                             size_t plaintext_len);
```

Encrypts application data for sending.

**Parameters:**
- `client` - client context
- `out` - output buffer for encrypted record
- `out_capacity` - capacity of output buffer
- `plaintext` - plaintext data to encrypt
- `plaintext_len` - length of plaintext

**Returns:** encrypted record length, or -1 on error.

#### `fio_tls13_client_decrypt`

```c
int fio_tls13_client_decrypt(fio_tls13_client_s *client,
                             uint8_t *out,
                             size_t out_capacity,
                             const uint8_t *ciphertext,
                             size_t ciphertext_len);
```

Decrypts received application data.

**Parameters:**
- `client` - client context
- `out` - output buffer for decrypted data
- `out_capacity` - capacity of output buffer
- `ciphertext` - encrypted record (including header)
- `ciphertext_len` - length of encrypted record

**Returns:** plaintext length, or -1 on error.

#### `fio_tls13_client_is_connected`

```c
int fio_tls13_client_is_connected(fio_tls13_client_s *client);
```

Checks if handshake is complete.

**Returns:** 1 if connected, 0 otherwise.

#### `fio_tls13_client_is_error`

```c
int fio_tls13_client_is_error(fio_tls13_client_s *client);
```

Checks if in error state.

**Returns:** 1 if error, 0 otherwise.

#### `fio_tls13_client_state_name`

```c
const char *fio_tls13_client_state_name(fio_tls13_client_s *client);
```

Gets current state name (for debugging).

**Returns:** state name string.

#### `fio_tls13_client_get_cert_error`

```c
int fio_tls13_client_get_cert_error(fio_tls13_client_s *client);
```

Gets the last certificate verification error.

**Returns:** error code (0 = OK, negative = error).

#### `fio_tls13_client_is_cert_verified`

```c
int fio_tls13_client_is_cert_verified(fio_tls13_client_s *client);
```

Checks if certificate verification was successful.

**Returns:** 1 if verified, 0 if not verified or skipped.

------------------------------------------------------------

### Complete Example

```c
#define FIO_TLS13
#define FIO_X509
#define FIO_RSA
#define FIO_SOCK
#include "fio-stl/include.h"

int tls_connect(const char *hostname, int port) {
  /* Connect TCP socket */
  int fd = /* ... establish TCP connection ... */;
  
  /* Initialize TLS client */
  fio_tls13_client_s client;
  fio_tls13_client_init(&client, hostname);
  
  /* Optional: Set trust store for certificate verification */
  fio_x509_trust_store_s trust_store = { /* ... */ };
  fio_tls13_client_set_trust_store(&client, &trust_store);
  
  /* Start handshake - send ClientHello */
  uint8_t out_buf[4096];
  int out_len = fio_tls13_client_start(&client, out_buf, sizeof(out_buf));
  if (out_len < 0) {
    fprintf(stderr, "Failed to create ClientHello\n");
    return -1;
  }
  send(fd, out_buf, out_len, 0);
  
  /* Process handshake messages until connected */
  uint8_t in_buf[16384];
  while (!fio_tls13_client_is_connected(&client)) {
    if (fio_tls13_client_is_error(&client)) {
      fprintf(stderr, "TLS handshake error\n");
      return -1;
    }
    
    /* Receive data */
    ssize_t recv_len = recv(fd, in_buf, sizeof(in_buf), 0);
    if (recv_len <= 0) break;
    
    /* Process received data */
    size_t response_len = 0;
    int consumed = fio_tls13_client_process(&client, in_buf, recv_len,
                                            out_buf, sizeof(out_buf),
                                            &response_len);
    if (consumed < 0) {
      fprintf(stderr, "TLS processing error\n");
      return -1;
    }
    
    /* Send any response (e.g., client Finished) */
    if (response_len > 0) {
      send(fd, out_buf, response_len, 0);
    }
  }
  
  printf("TLS 1.3 handshake complete!\n");
  printf("Cipher suite: 0x%04X\n", client.cipher_suite);
  
  /* Send encrypted application data */
  const char *request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
  int enc_len = fio_tls13_client_encrypt(&client, out_buf, sizeof(out_buf),
                                         (uint8_t*)request, strlen(request));
  send(fd, out_buf, enc_len, 0);
  
  /* Receive and decrypt response */
  ssize_t recv_len = recv(fd, in_buf, sizeof(in_buf), 0);
  int dec_len = fio_tls13_client_decrypt(&client, out_buf, sizeof(out_buf),
                                         in_buf, recv_len);
  if (dec_len > 0) {
    printf("Response: %.*s\n", dec_len, out_buf);
  }
  
  /* Clean up */
  fio_tls13_client_destroy(&client);
  close(fd);
  
  return 0;
}
```

------------------------------------------------------------
